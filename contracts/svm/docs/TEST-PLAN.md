# Solana åˆçº¦å­æ¨¡å— - æµ‹è¯•å¥—ä»¶è§„åˆ’

> **æ–‡æ¡£ç‰ˆæœ¬**: v1.0  
> **åˆ›å»ºæ—¥æœŸ**: 2025-11-08  
> **å­æ¨¡å—èŒƒå›´**: Solanaç¨‹åºæµ‹è¯•è§„èŒƒ

---

## ğŸ“‹ ç›®å½•

1. [æµ‹è¯•ç­–ç•¥](#1-æµ‹è¯•ç­–ç•¥)
2. [ç¨‹åºå•å…ƒæµ‹è¯•](#2-ç¨‹åºå•å…ƒæµ‹è¯•)
3. [ç¨‹åºé›†æˆæµ‹è¯•](#3-ç¨‹åºé›†æˆæµ‹è¯•)
4. [è·¨é“¾E2Eæµ‹è¯•](#4-è·¨é“¾e2eæµ‹è¯•)
5. [æµ‹è¯•ç¯å¢ƒé…ç½®](#5-æµ‹è¯•ç¯å¢ƒé…ç½®)

---

## 1. æµ‹è¯•ç­–ç•¥

### 1.1 æµ‹è¯•åˆ†å±‚

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  E2Eæµ‹è¯• (è·¨é“¾å®Œæ•´æµç¨‹)                    â”‚  20%
â”‚  - Solana â†’ Ethereum                      â”‚
â”‚  - Ethereum â†’ Solana                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                 â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  ç¨‹åºé›†æˆæµ‹è¯•                             â”‚  30%
â”‚  - solana-core + token-bridge             â”‚
â”‚  - å¤šæŒ‡ä»¤äº¤äº’                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                 â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  ç¨‹åºå•å…ƒæµ‹è¯•                             â”‚  50%
â”‚  - å„æŒ‡ä»¤ç‹¬ç«‹æµ‹è¯•                         â”‚
â”‚  - è¾¹ç•Œæ¡ä»¶å’Œé”™è¯¯å¤„ç†                     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 1.2 æµ‹è¯•è¦†ç›–ç›®æ ‡

| æµ‹è¯•ç±»å‹ | è¦†ç›–ç‡ç›®æ ‡ | ç”¨ä¾‹æ•° | é¢„è®¡æ—¶é—´ |
|---------|-----------|--------|---------|
| **ç¨‹åºå•å…ƒæµ‹è¯•** | 90%ä»£ç  | 30ä¸ª | 15åˆ†é’Ÿ |
| **é›†æˆæµ‹è¯•** | 80%æµç¨‹ | 12ä¸ª | 20åˆ†é’Ÿ |
| **E2Eæµ‹è¯•** | 100%å…³é”®æµç¨‹ | 5ä¸ª | 25åˆ†é’Ÿ |
| **æ€»è®¡** | - | **47ä¸ª** | **60åˆ†é’Ÿ** |

---

## 2. ç¨‹åºå•å…ƒæµ‹è¯•

### 2.1 solana-core å•å…ƒæµ‹è¯•

#### 2.1.1 initializeæŒ‡ä»¤æµ‹è¯•

| æµ‹è¯•ID | æµ‹è¯•åœºæ™¯ | ä¼˜å…ˆçº§ |
|-------|---------|--------|
| UNIT-SC-001 | æ­£å¸¸åˆå§‹åŒ–Bridge | P0 |
| UNIT-SC-002 | åˆå§‹åŒ–Guardian Set | P0 |
| UNIT-SC-003 | è®¾ç½®åˆå§‹message_fee | P0 |
| UNIT-SC-004 | é‡å¤åˆå§‹åŒ–å¤±è´¥ | P0 |

**æµ‹è¯•ç¤ºä¾‹ UNIT-SC-001**:
```rust
#[tokio::test]
async fn test_initialize_bridge() {
    let program = setup_program().await;
    
    // å‡†å¤‡Guardianåˆ—è¡¨
    let guardians = vec![
        guardian_address_1(),
        guardian_address_2(),
        // ... 19ä¸ªGuardian
    ];
    
    // è°ƒç”¨initialize
    let tx = program.methods()
        .initialize(0, guardians.clone(), 1_000_000)
        .accounts({
            bridge: bridge_pda,
            guardian_set: guardian_set_pda,
            payer: payer.pubkey(),
            system_program: system_program::ID,
        })
        .signer(&payer)
        .rpc()
        .await;
    
    assert!(tx.is_ok());
    
    // éªŒè¯Bridgeè´¦æˆ·
    let bridge = program.account::<Bridge>(bridge_pda).await?;
    assert_eq!(bridge.guardian_set_index, 0);
    assert_eq!(bridge.message_fee, 1_000_000);
    assert_eq!(bridge.paused, false);
    
    // éªŒè¯GuardianSetè´¦æˆ·
    let guardian_set = program.account::<GuardianSet>(guardian_set_pda).await?;
    assert_eq!(guardian_set.guardians.len(), 19);
    assert_eq!(guardian_set.guardians, guardians);
}
```

---

#### 2.1.2 post_messageæŒ‡ä»¤æµ‹è¯•

| æµ‹è¯•ID | æµ‹è¯•åœºæ™¯ | ä¼˜å…ˆçº§ |
|-------|---------|--------|
| UNIT-SC-005 | æ­£å¸¸å‘é€æ¶ˆæ¯ | P0 |
| UNIT-SC-006 | åºåˆ—å·é€’å¢ | P0 |
| UNIT-SC-007 | æ‰‹ç»­è´¹ä¸è¶³ | P0 |
| UNIT-SC-008 | payloadå¤§å°é™åˆ¶ | P1 |
| UNIT-SC-009 | Bridgeæš‚åœæ—¶æ‹’ç» | P0 |

**æµ‹è¯•ç¤ºä¾‹ UNIT-SC-005**:
```rust
#[tokio::test]
async fn test_post_message() {
    let program = setup_initialized_program().await;
    
    let payload = vec![1, 2, 3, 4, 5];
    let nonce = 12345u32;
    
    // å‘é€æ¶ˆæ¯
    let tx = program.methods()
        .post_message(nonce, payload.clone(), 32)
        .accounts({
            bridge: bridge_pda,
            message: message_pda,
            emitter: emitter.pubkey(),
            sequence: sequence_pda,
            payer: payer.pubkey(),
            system_program: system_program::ID,
        })
        .signers([&emitter, &payer])
        .rpc()
        .await?;
    
    // éªŒè¯æ¶ˆæ¯è´¦æˆ·
    let message = program.account::<PostedMessage>(message_pda).await?;
    assert_eq!(message.nonce, nonce);
    assert_eq!(message.payload, payload);
    assert_eq!(message.consistency_level, 32);
    assert_eq!(message.sequence, 0);  // ç¬¬ä¸€æ¡æ¶ˆæ¯
    
    // éªŒè¯åºåˆ—å·é€’å¢
    let sequence = program.account::<Sequence>(sequence_pda).await?;
    assert_eq!(sequence.sequence, 1);
}
```

---

#### 2.1.3 post_vaaæŒ‡ä»¤æµ‹è¯•

| æµ‹è¯•ID | æµ‹è¯•åœºæ™¯ | ä¼˜å…ˆçº§ |
|-------|---------|--------|
| UNIT-SC-010 | æ­£å¸¸æ¥æ”¶VAA | P0 |
| UNIT-SC-011 | VAAç­¾åéªŒè¯æˆåŠŸ | P0 |
| UNIT-SC-012 | ç­¾åæ•°é‡ä¸è¶³ï¼ˆ<13ï¼‰ | P0 |
| UNIT-SC-013 | æ— æ•ˆç­¾å | P0 |
| UNIT-SC-014 | Guardian Setè¿‡æœŸ | P0 |
| UNIT-SC-015 | VAAé‡å¤æ¶ˆè´¹ | P0 |
| UNIT-SC-016 | æ— æ•ˆçš„VAAæ ¼å¼ | P1 |

**æµ‹è¯•ç¤ºä¾‹ UNIT-SC-010**:
```rust
#[tokio::test]
async fn test_post_vaa_success() {
    let program = setup_initialized_program().await;
    
    // æ„é€ æµ‹è¯•VAAï¼ˆ13ä¸ªGuardianç­¾åï¼‰
    let vaa = create_test_vaa(
        guardian_set_index: 0,
        emitter_chain: 1,  // Ethereum
        emitter_address: eth_bridge_address,
        sequence: 42,
        payload: token_transfer_payload,
        guardians: &test_guardians[0..13],  // 13ä¸ªç­¾å
    );
    
    // æäº¤VAA
    let tx = program.methods()
        .post_vaa(vaa.clone())
        .accounts({
            bridge: bridge_pda,
            guardian_set: guardian_set_pda,
            posted_vaa: posted_vaa_pda,
            payer: payer.pubkey(),
            system_program: system_program::ID,
        })
        .signer(&payer)
        .rpc()
        .await?;
    
    // éªŒè¯PostedVAAè´¦æˆ·
    let posted_vaa = program.account::<PostedVAA>(posted_vaa_pda).await?;
    assert_eq!(posted_vaa.emitter_chain, 1);
    assert_eq!(posted_vaa.sequence, 42);
    assert_eq!(posted_vaa.consumed, false);
}
```

**æµ‹è¯•ç¤ºä¾‹ UNIT-SC-012**:
```rust
#[tokio::test]
async fn test_post_vaa_insufficient_signatures() {
    let program = setup_initialized_program().await;
    
    // æ„é€ åªæœ‰12ä¸ªç­¾åçš„VAAï¼ˆéœ€è¦13ä¸ªï¼‰
    let vaa = create_test_vaa(
        guardian_set_index: 0,
        guardians: &test_guardians[0..12],  // åªæœ‰12ä¸ªç­¾å
        ...
    );
    
    // åº”è¯¥å¤±è´¥
    let result = program.methods()
        .post_vaa(vaa)
        .accounts({ ... })
        .rpc()
        .await;
    
    assert!(result.is_err());
    assert_eq!(
        result.unwrap_err().to_string(),
        "Insufficient signatures (requires 13/19)"
    );
}
```

---

#### 2.1.4 update_guardian_setæŒ‡ä»¤æµ‹è¯•

| æµ‹è¯•ID | æµ‹è¯•åœºæ™¯ | ä¼˜å…ˆçº§ |
|-------|---------|--------|
| UNIT-SC-017 | æ­£å¸¸å‡çº§Guardian Set | P0 |
| UNIT-SC-018 | æ–°æ—§Setå¹¶å­˜ï¼ˆè¿‡æ¸¡æœŸï¼‰ | P0 |
| UNIT-SC-019 | æ—§Setè¿‡æœŸåæ‹’ç» | P0 |
| UNIT-SC-020 | éæ²»ç†VAAæ‹’ç» | P0 |

**æµ‹è¯•ç¤ºä¾‹ UNIT-SC-017**:
```rust
#[tokio::test]
async fn test_update_guardian_set() {
    let program = setup_initialized_program().await;
    
    // æ„é€ å‡çº§VAAï¼ˆç”±æ—§Guardian Setç­¾åï¼‰
    let new_guardians = generate_new_guardians(19);
    let payload = GuardianSetUpgradePayload {
        module: 0x01,
        action: 0x02,
        chain: 0,
        new_index: 1,
        new_guardians: new_guardians.clone(),
    };
    
    let vaa = create_governance_vaa(
        guardian_set_index: 0,
        payload: payload.serialize(),
        guardians: &current_guardians,
    );
    
    // æ‰§è¡Œå‡çº§
    let tx = program.methods()
        .update_guardian_set(vaa)
        .accounts({
            bridge: bridge_pda,
            current_guardian_set: guardian_set_0_pda,
            new_guardian_set: guardian_set_1_pda,
            payer: payer.pubkey(),
            system_program: system_program::ID,
        })
        .signer(&payer)
        .rpc()
        .await?;
    
    // éªŒè¯Bridgeæ›´æ–°
    let bridge = program.account::<Bridge>(bridge_pda).await?;
    assert_eq!(bridge.guardian_set_index, 1);
    
    // éªŒè¯æ–°Setåˆ›å»º
    let new_set = program.account::<GuardianSet>(guardian_set_1_pda).await?;
    assert_eq!(new_set.index, 1);
    assert_eq!(new_set.guardians, new_guardians);
    assert_eq!(new_set.expiration_time, 0);  // Active
    
    // éªŒè¯æ—§Setè®¾ç½®è¿‡æœŸæ—¶é—´ï¼ˆ7å¤©åï¼‰
    let old_set = program.account::<GuardianSet>(guardian_set_0_pda).await?;
    assert!(old_set.expiration_time > 0);
    assert_eq!(old_set.expiration_time, now + 7 * 86400);
}
```

---

### 2.2 token-bridge å•å…ƒæµ‹è¯•

#### 2.2.1 transfer_tokensæŒ‡ä»¤æµ‹è¯•

| æµ‹è¯•ID | æµ‹è¯•åœºæ™¯ | ä¼˜å…ˆçº§ |
|-------|---------|--------|
| UNIT-TB-001 | æ­£å¸¸é”å®šSPLä»£å¸ | P0 |
| UNIT-TB-002 | æˆæƒä¸è¶³ | P0 |
| UNIT-TB-003 | ä½™é¢ä¸è¶³ | P0 |
| UNIT-TB-004 | æ‰‹ç»­è´¹ä¸è¶³ | P0 |
| UNIT-TB-005 | æ— æ•ˆç›®æ ‡é“¾ | P1 |

**æµ‹è¯•ç¤ºä¾‹ UNIT-TB-001**:
```rust
#[tokio::test]
async fn test_transfer_tokens() {
    let program = setup_token_bridge_program().await;
    
    // åˆ›å»ºæµ‹è¯•ä»£å¸
    let mint = create_test_mint(&program, 6).await?;
    let user_token_account = create_token_account(&program, &mint, &user).await?;
    mint_to(&program, &mint, &user_token_account, 1000_000_000).await?;
    
    let amount = 500_000_000;  // 500 USDC
    let target_chain = 1;       // Ethereum
    let recipient = eth_address_bytes32();
    
    // æ‰§è¡Œè½¬è´¦
    let tx = program.methods()
        .transfer_tokens(amount, target_chain, recipient)
        .accounts({
            bridge: bridge_pda,
            token_account: user_token_account,
            custody_account: custody_pda,
            token_authority: user.pubkey(),
            token_program: token_program::ID,
        })
        .signer(&user)
        .rpc()
        .await?;
    
    // éªŒè¯ä»£å¸é”å®š
    let custody = get_token_account(&program, custody_pda).await?;
    assert_eq!(custody.amount, amount);
    
    // éªŒè¯ç”¨æˆ·ä½™é¢å‡å°‘
    let user_account = get_token_account(&program, user_token_account).await?;
    assert_eq!(user_account.amount, 500_000_000);
    
    // éªŒè¯æ¶ˆæ¯å‘é€
    let sequence = program.account::<Sequence>(sequence_pda).await?;
    assert_eq!(sequence.sequence, 1);
}
```

---

#### 2.2.2 complete_transferæŒ‡ä»¤æµ‹è¯•

| æµ‹è¯•ID | æµ‹è¯•åœºæ™¯ | ä¼˜å…ˆçº§ |
|-------|---------|--------|
| UNIT-TB-006 | è§£é”åŸç”ŸSPLä»£å¸ | P0 |
| UNIT-TB-007 | é“¸é€ åŒ…è£…ä»£å¸ | P0 |
| UNIT-TB-008 | VAAéªŒè¯å¤±è´¥ | P0 |
| UNIT-TB-009 | ç›®æ ‡é“¾ä¸åŒ¹é… | P0 |
| UNIT-TB-010 | ä½™é¢ä¸è¶³ï¼ˆcustodyï¼‰ | P0 |

**æµ‹è¯•ç¤ºä¾‹ UNIT-TB-006**:
```rust
#[tokio::test]
async fn test_complete_transfer_unlock() {
    let program = setup_token_bridge_program().await;
    
    // é¢„å…ˆé”å®šä¸€äº›ä»£å¸åˆ°custody
    let custody_amount = 1000_000_000;
    setup_custody_balance(&program, &mint, custody_amount).await?;
    
    // æ„é€ æ¥è‡ªEthereumçš„è½¬è´¦VAA
    let payload = TokenTransferPayload {
        payload_type: 1,
        amount: 500_000_000,
        token_address: mint.pubkey().to_bytes(),
        token_chain: 2,  // SolanaåŸç”Ÿ
        recipient: user.pubkey().to_bytes(),
        recipient_chain: 2,  // Solana
    };
    
    let vaa = create_token_transfer_vaa(
        emitter_chain: 1,  // Ethereum
        payload: payload.serialize(),
        guardians: &test_guardians[0..13],
    );
    
    // å®Œæˆè½¬è´¦
    let tx = program.methods()
        .complete_transfer(vaa)
        .accounts({
            bridge: bridge_pda,
            posted_vaa: posted_vaa_pda,
            recipient_account: user_token_account,
            custody_or_mint: custody_pda,
            token_program: token_program::ID,
        })
        .rpc()
        .await?;
    
    // éªŒè¯ç”¨æˆ·æ”¶åˆ°ä»£å¸
    let user_account = get_token_account(&program, user_token_account).await?;
    assert_eq!(user_account.amount, 500_000_000);
    
    // éªŒè¯custodyå‡å°‘
    let custody = get_token_account(&program, custody_pda).await?;
    assert_eq!(custody.amount, 500_000_000);
    
    // éªŒè¯VAAæ ‡è®°ä¸ºå·²æ¶ˆè´¹
    let posted_vaa = program.account::<PostedVAA>(posted_vaa_pda).await?;
    assert_eq!(posted_vaa.consumed, true);
}
```

---

#### 2.2.3 create_wrappedæŒ‡ä»¤æµ‹è¯•

| æµ‹è¯•ID | æµ‹è¯•åœºæ™¯ | ä¼˜å…ˆçº§ |
|-------|---------|--------|
| UNIT-TB-011 | åˆ›å»ºåŒ…è£…ä»£å¸ | P0 |
| UNIT-TB-012 | é‡å¤åˆ›å»ºå¤±è´¥ | P0 |

**æµ‹è¯•ç¤ºä¾‹ UNIT-TB-011**:
```rust
#[tokio::test]
async fn test_create_wrapped() {
    let program = setup_token_bridge_program().await;
    
    // Ethereum USDCåœ°å€
    let eth_usdc = [0xA0, 0xb8, 0x69, 0x91, ...];  // 32å­—èŠ‚
    
    let tx = program.methods()
        .create_wrapped(1, eth_usdc, 6)
        .accounts({
            wrapped_mint: wrapped_mint_pda,
            wrapped_meta: wrapped_meta_pda,
            payer: payer.pubkey(),
            token_program: token_program::ID,
            system_program: system_program::ID,
        })
        .signer(&payer)
        .rpc()
        .await?;
    
    // éªŒè¯Mintåˆ›å»º
    let mint = get_mint(&program, wrapped_mint_pda).await?;
    assert_eq!(mint.decimals, 6);
    assert_eq!(mint.mint_authority, Some(token_bridge_authority_pda));
    
    // éªŒè¯WrappedMeta
    let meta = program.account::<WrappedMeta>(wrapped_meta_pda).await?;
    assert_eq!(meta.original_chain, 1);
    assert_eq!(meta.original_address, eth_usdc);
    assert_eq!(meta.decimals, 6);
}
```

---

## 3. ç¨‹åºé›†æˆæµ‹è¯•

### 3.1 è·¨ç¨‹åºè°ƒç”¨æµ‹è¯•

| æµ‹è¯•ID | æµ‹è¯•åœºæ™¯ | ä¼˜å…ˆçº§ |
|-------|---------|--------|
| INT-SOL-001 | transfer_tokens â†’ post_message | P0 |
| INT-SOL-002 | post_vaa â†’ complete_transfer | P0 |
| INT-SOL-003 | å¤šæ­¥éª¤åŸå­æ€§ | P0 |

**æµ‹è¯•ç¤ºä¾‹ INT-SOL-001**:
```rust
#[tokio::test]
async fn test_transfer_posts_message() {
    let (core_program, token_program) = setup_both_programs().await;
    
    // æ‰§è¡Œtransfer_tokens
    let tx = token_program.methods()
        .transfer_tokens(1000_000_000, 1, eth_recipient)
        .accounts({ ... })
        .rpc()
        .await?;
    
    // éªŒè¯post_messageè¢«è°ƒç”¨
    let sequence = core_program.account::<Sequence>(sequence_pda).await?;
    assert_eq!(sequence.sequence, 1);
    
    // éªŒè¯æ¶ˆæ¯å†…å®¹
    let message = core_program.account::<PostedMessage>(message_pda).await?;
    let payload = TokenTransferPayload::deserialize(&message.payload)?;
    assert_eq!(payload.amount, 1000_000_000);
    assert_eq!(payload.recipient_chain, 1);
}
```

---

### 3.2 Guardian Setå‡çº§æµ‹è¯•

| æµ‹è¯•ID | æµ‹è¯•åœºæ™¯ | ä¼˜å…ˆçº§ |
|-------|---------|--------|
| INT-SOL-004 | å‡çº§åæ—§Setä»å¯éªŒè¯ | P0 |
| INT-SOL-005 | å‡çº§åæ–°Setå¯éªŒè¯ | P0 |
| INT-SOL-006 | è¿‡æœŸåæ—§Setæ‹’ç» | P0 |

**æµ‹è¯•ç¤ºä¾‹ INT-SOL-004**:
```rust
#[tokio::test]
async fn test_guardian_upgrade_transition() {
    let program = setup_initialized_program().await;
    
    // 1. å‡çº§Guardian Set
    upgrade_guardian_set(&program, new_guardians).await?;
    
    // 2. æµ‹è¯•æ—§Setç­¾åçš„VAAï¼ˆè¿‡æ¸¡æœŸå†…ï¼‰
    let vaa_old = create_test_vaa(
        guardian_set_index: 0,  // æ—§Set
        guardians: &old_guardians[0..13],
        ...
    );
    
    let result = program.methods()
        .post_vaa(vaa_old)
        .accounts({ ... })
        .rpc()
        .await;
    
    assert!(result.is_ok());  // è¿‡æ¸¡æœŸå†…æ—§Setæœ‰æ•ˆ
    
    // 3. æµ‹è¯•æ–°Setç­¾åçš„VAA
    let vaa_new = create_test_vaa(
        guardian_set_index: 1,  // æ–°Set
        guardians: &new_guardians[0..13],
        ...
    );
    
    let result = program.methods()
        .post_vaa(vaa_new)
        .accounts({ ... })
        .rpc()
        .await;
    
    assert!(result.is_ok());  // æ–°Setä¹Ÿæœ‰æ•ˆ
    
    // 4. 7å¤©åæµ‹è¯•æ—§Setï¼ˆåº”å¤±è´¥ï¼‰
    advance_time(7 * 86400 + 1).await;
    
    let vaa_old_expired = create_test_vaa(
        guardian_set_index: 0,
        guardians: &old_guardians[0..13],
        ...
    );
    
    let result = program.methods()
        .post_vaa(vaa_old_expired)
        .accounts({ ... })
        .rpc()
        .await;
    
    assert!(result.is_err());  // æ—§Setå·²è¿‡æœŸ
    assert_eq!(result.unwrap_err().to_string(), "Guardian set expired");
}
```

---

## 4. è·¨é“¾E2Eæµ‹è¯•

### 4.1 Solana â†’ Ethereum

| æµ‹è¯•ID | æµ‹è¯•åœºæ™¯ | ä¼˜å…ˆçº§ | é¢„è®¡æ—¶é—´ |
|-------|---------|--------|---------|
| E2E-SOL-001 | SPLä»£å¸è·¨é“¾åˆ°Ethereum | P0 | 2åˆ†é’Ÿ |
| E2E-SOL-002 | Ethereumè§£é”åŸç”ŸERC20 | P0 | 1åˆ†é’Ÿ |

**æµ‹è¯•ç¤ºä¾‹ E2E-SOL-001**:
```typescript
// E2Eæµ‹è¯•è„šæœ¬
describe("Solana to Ethereum Transfer", () => {
  it("should transfer SPL token and receive ERC20", async () => {
    // 1. Solana: é”å®šSPLä»£å¸
    const tx = await tokenBridge.methods
      .transferTokens(
        new BN(1000_000_000),  // 1000 USDC
        1,                      // Target chain: Ethereum
        ethRecipient
      )
      .rpc();
    
    console.log("Solana TX:", tx);
    
    // 2. ç­‰å¾…Guardianç­¾å
    const sequence = await getSequenceNumber(tx);
    const vaa = await pollGuardianForVAA({
      emitterChain: 2,
      emitterAddress: tokenBridgeProgramId,
      sequence: sequence,
    });
    
    assert(vaa.signatures.length >= 13);
    
    // 3. Relayeræäº¤åˆ°Ethereum
    const ethTx = await ethBridgeCore.receiveMessage(vaa);
    await ethTx.wait();
    
    // 4. éªŒè¯Ethereumä½™é¢
    const balance = await ethUSDC.balanceOf(ethRecipient);
    expect(balance).to.equal(ethers.utils.parseUnits("1000", 6));
  });
});
```

---

### 4.2 Ethereum â†’ Solana

| æµ‹è¯•ID | æµ‹è¯•åœºæ™¯ | ä¼˜å…ˆçº§ | é¢„è®¡æ—¶é—´ |
|-------|---------|--------|---------|
| E2E-SOL-003 | ERC20è·¨é“¾åˆ°Solana | P0 | 2åˆ†é’Ÿ |
| E2E-SOL-004 | Solanaé“¸é€ wrappedToken | P0 | 1åˆ†é’Ÿ |

**æµ‹è¯•ç¤ºä¾‹ E2E-SOL-003**:
```typescript
describe("Ethereum to Solana Transfer", () => {
  it("should lock ERC20 and mint wrapped SPL", async () => {
    // 1. Ethereum: é”å®šERC20
    const tx = await ethTokenVault.lockTokens(
      ethUSDC.address,
      ethers.utils.parseUnits("1000", 6),
      2,  // Target chain: Solana
      solanaRecipient
    );
    await tx.wait();
    
    // 2. è·å–VAA
    const sequence = await extractSequence(tx);
    const vaa = await pollGuardianForVAA({
      emitterChain: 1,
      emitterAddress: ethTokenVault.address,
      sequence: sequence,
    });
    
    // 3. Solana: post_vaa
    const postVaaTx = await solanaCore.methods
      .postVaa(vaa)
      .rpc();
    
    // 4. Solana: complete_transfer
    const completeTx = await tokenBridge.methods
      .completeTransfer(vaa)
      .rpc();
    
    // 5. éªŒè¯Solanaä½™é¢
    const account = await getAccount(
      connection,
      solanaRecipientTokenAccount
    );
    expect(account.amount).to.equal(1000_000_000n);
  });
});
```

---

### 4.3 Guardianå‡çº§è·¨é“¾æµ‹è¯•

| æµ‹è¯•ID | æµ‹è¯•åœºæ™¯ | ä¼˜å…ˆçº§ | é¢„è®¡æ—¶é—´ |
|-------|---------|--------|---------|
| E2E-SOL-005 | Solana Guardianå‡çº§åŸå­æ€§ | P0 | 5åˆ†é’Ÿ |

**æµ‹è¯•æµç¨‹**:
```
1. åœ¨Ethereumå‡çº§Guardian Set
2. ç­‰å¾…VAAç”Ÿæˆ
3. åœ¨Solanaæäº¤å‡çº§VAA
4. éªŒè¯ä¸¤æ¡é“¾Guardian SetåŒæ­¥
5. æµ‹è¯•è¿‡æ¸¡æœŸå†…è·¨é“¾æ¶ˆæ¯
6. éªŒè¯æ–°æ—§Setéƒ½èƒ½å·¥ä½œ
```

---

## 5. æµ‹è¯•ç¯å¢ƒé…ç½®

### 5.1 æœ¬åœ°æµ‹è¯•ç¯å¢ƒ

#### Anchor.tomlé…ç½®
```toml
[features]
seeds = false
skip-lint = false

[programs.localnet]
solana_core = "worm2ZoG2kUd4vFXhvjh93UUH596ayRfgQ2MgjNMTth"
token_bridge = "wormDTUJ6AWPNvk59vGQbDvGJmqbDTdgWgAqcLBCgUb"

[scripts]
test = "yarn run ts-mocha -p ./tsconfig.json -t 1000000 tests/**/*.ts"

[test]
startup_wait = 5000

[[test.validator.clone]]
address = "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA"

[[test.validator.clone]]
address = "ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL"
```

---

### 5.2 æµ‹è¯•å·¥å…·å‡½æ•°

```typescript
// tests/utils/helpers.ts

/**
 * åˆ›å»ºæµ‹è¯•VAA
 */
export function createTestVAA(params: {
  guardianSetIndex: number;
  emitterChain: number;
  emitterAddress: string;
  sequence: number;
  payload: Buffer;
  guardians: Keypair[];
}): Buffer {
  // VAAæ„é€ é€»è¾‘
  const header = Buffer.alloc(6);
  header.writeUInt8(1, 0);  // version
  header.writeUInt32BE(params.guardianSetIndex, 1);
  header.writeUInt8(params.guardians.length, 5);
  
  // ç­¾åéƒ¨åˆ†
  const bodyHash = keccak256(encodeBody(params));
  const signatures = params.guardians.map((guardian, index) => {
    const sig = guardian.sign(bodyHash);
    return Buffer.concat([
      Buffer.from([index]),
      sig
    ]);
  });
  
  return Buffer.concat([header, ...signatures, encodeBody(params)]);
}

/**
 * ä»Guardian APIè½®è¯¢VAA
 */
export async function pollGuardianForVAA(
  messageId: {
    emitterChain: number;
    emitterAddress: string;
    sequence: number;
  },
  timeout: number = 60000
): Promise<Buffer> {
  const startTime = Date.now();
  
  while (Date.now() - startTime < timeout) {
    try {
      const response = await fetch(
        `http://localhost:7071/v1/signed_vaa/${messageId.emitterChain}/${messageId.emitterAddress}/${messageId.sequence}`
      );
      
      if (response.status === 200) {
        const data = await response.json();
        return Buffer.from(data.vaaBytes.slice(2), 'hex');
      }
      
      if (response.status === 404) {
        throw new Error("VAA not found");
      }
      
      // 202: èšåˆä¸­ï¼Œç»§ç»­ç­‰å¾…
      await new Promise(resolve => setTimeout(resolve, 1000));
    } catch (err) {
      console.log("Polling VAA...", err.message);
      await new Promise(resolve => setTimeout(resolve, 1000));
    }
  }
  
  throw new Error("VAA timeout");
}
```

---

### 5.3 CI/CDé…ç½®

```yaml
# .github/workflows/solana-test.yml
name: Solana Contract Tests

on: [push, pull_request]

jobs:
  test:
    runs-on: ubuntu-latest
    
    steps:
      - uses: actions/checkout@v3
      
      - name: Install Solana
        run: |
          sh -c "$(curl -sSfL https://release.solana.com/stable/install)"
          echo "$HOME/.local/share/solana/install/active_release/bin" >> $GITHUB_PATH
      
      - name: Install Anchor
        run: |
          cargo install --git https://github.com/coral-xyz/anchor anchor-cli --locked
      
      - name: Run Anchor tests
        working-directory: contracts/svm
        run: |
          anchor test
      
      - name: Upload test results
        if: always()
        uses: actions/upload-artifact@v3
        with:
          name: test-results
          path: contracts/svm/test-results/
```

---

## é™„å½•

### A. æµ‹è¯•å®ç°è¯´æ˜

#### A.1 çœŸå®å¯†ç å­¦å®ç°

æµ‹è¯•å¥—ä»¶ä½¿ç”¨**çœŸå®çš„å¯†ç å­¦ç®—æ³•**ï¼Œè€Œä¸æ˜¯æ¨¡æ‹Ÿæ•°æ®ï¼š

**Guardianå¯†é’¥ç”Ÿæˆï¼ˆsecp256k1ï¼‰**:
```typescript
// ä½¿ç”¨ellipticåº“ç”ŸæˆçœŸå®çš„secp256k1å¯†é’¥å¯¹
import { ec as EC } from "elliptic";
const ec = new EC("secp256k1");

export function generateGuardianKey(seed?: Buffer): GuardianKeyPair {
  const privateKey = seed || crypto.randomBytes(32);
  const key = ec.keyFromPrivate(privateKey);
  
  // è®¡ç®—Ethereumå…¼å®¹çš„20å­—èŠ‚åœ°å€
  const publicKey = Buffer.concat([
    Buffer.from(key.getX().toArray('be', 32)),
    Buffer.from(key.getY().toArray('be', 32))
  ]);
  const publicKeyHash = Buffer.from(keccak256(publicKey), 'hex');
  const address = publicKeyHash.slice(-20);
  
  return { privateKey, publicKey, address };
}

// ç”Ÿæˆ19ä¸ªGuardianå¯†é’¥
export const TEST_GUARDIAN_KEYS = generateGuardianKeys(19);
```

**ECDSAç­¾å**:
```typescript
export function signVAA(bodyHash: Buffer, guardianKey: GuardianKeyPair, guardianIndex: number) {
  const key = ec.keyFromPrivate(guardianKey.privateKey);
  const signature = key.sign(bodyHash, { canonical: true });
  
  return {
    guardianIndex,
    r: Buffer.from(signature.r.toArray('be', 32)),
    s: Buffer.from(signature.s.toArray('be', 32)),
    v: signature.recoveryParam!,
  };
}
```

**ç­¾åéªŒè¯**:
```typescript
export function verifyVAASignature(bodyHash: Buffer, signature: Signature, guardianAddress: Buffer) {
  const key = ec.recoverPubKey(bodyHash, { r: signature.r, s: signature.s }, signature.v);
  const publicKey = Buffer.concat([...]);
  const recoveredAddress = Buffer.from(keccak256(publicKey), 'hex').slice(-20);
  return recoveredAddress.equals(guardianAddress);
}
```

#### A.2 VAAæ„é€ 

**å®Œæ•´VAAæ„é€ æµç¨‹**:
```typescript
export function createTokenTransferVAA(params: {
  guardianSetIndex: number;
  emitterChain: number;
  emitterAddress: Buffer;
  sequence: bigint;
  guardianKeys: GuardianKeyPair[];  // çœŸå®çš„secp256k1å¯†é’¥
  transferPayload: TokenTransferPayload;
  signerCount?: number;  // é»˜è®¤13
}): Buffer {
  // 1. åºåˆ—åŒ–Payload
  const payload = serializeTokenTransferPayload(params.transferPayload);
  
  // 2. åºåˆ—åŒ–Body
  const bodyBuffer = serializeVAABody({ timestamp, nonce, emitterChain, ... });
  
  // 3. è®¡ç®—åŒé‡å“ˆå¸Œ
  const bodyHash = keccak256(bodyBuffer);
  const doubleHash = keccak256(bodyHash);
  
  // 4. ç”ŸæˆçœŸå®ç­¾åï¼ˆ13ä¸ªGuardianï¼‰
  const signatures = [];
  for (let i = 0; i < 13; i++) {
    signatures.push(signVAA(doubleHash, guardianKeys[i], i));
  }
  
  // 5. åºåˆ—åŒ–å®Œæ•´VAA
  return serializeVAA({ version: 1, guardianSetIndex, signatures, ... });
}
```

#### A.3 æµ‹è¯•è¿è¡Œ

```bash
# è¿è¡Œå¯†ç å­¦æ¼”ç¤ºæµ‹è¯•
cd contracts/svm/bridge-programs
ts-mocha -p ./tsconfig.json tests/demo-crypto.test.ts

# è¾“å‡ºç¤ºä¾‹ï¼š
# âœ“ ç”Ÿæˆ19ä¸ªGuardianå¯†é’¥
#   Guardian 0: 0x8c8c3c3d9e8e8e8e8e8e8e8e8e8e8e8e8e8e8e8e
# âœ“ ECDSAç­¾åå’ŒéªŒè¯: âœ“ é€šè¿‡
# âœ“ VAAæ„é€ å®Œæˆ: 1122 bytes, 13/13ç­¾åéªŒè¯é€šè¿‡
```

#### A.4 æµ‹è¯•è¦†ç›–

| åŠŸèƒ½ | å®ç°æ–¹å¼ | çŠ¶æ€ |
|------|---------|------|
| secp256k1å¯†é’¥ç”Ÿæˆ | `elliptic`åº“ | âœ… çœŸå®å®ç° |
| ECDSAç­¾å | `elliptic.sign()` | âœ… çœŸå®å®ç° |
| ç­¾åéªŒè¯ | `elliptic.recoverPubKey()` | âœ… çœŸå®å®ç° |
| Keccak256å“ˆå¸Œ | `js-sha3` | âœ… çœŸå®å®ç° |
| VAAåºåˆ—åŒ– | ç¬¦åˆWormholeåè®® | âœ… å®Œæ•´å®ç° |
| TokenTransfer Payload | 133å­—èŠ‚æ ¼å¼ | âœ… å®Œæ•´å®ç° |
| GuardianSetUpgrade Payload | å¯å˜é•¿åº¦æ ¼å¼ | âœ… å®Œæ•´å®ç° |

---

### B. è¦†ç›–ç‡æŠ¥å‘Š

ä½¿ç”¨ `anchor-coverage` å·¥å…·ç”Ÿæˆè¦†ç›–ç‡æŠ¥å‘Šï¼š

```bash
cd contracts/svm
anchor test --skip-deploy
anchor coverage
```

**ç›®æ ‡è¦†ç›–ç‡**:
- æŒ‡ä»¤è¦†ç›–ç‡: 100%
- åˆ†æ”¯è¦†ç›–ç‡: 90%
- è¡Œè¦†ç›–ç‡: 90%

---

**æ–‡æ¡£çŠ¶æ€**: âœ… v1.0 åˆç‰ˆå®Œæˆ  
**ç»´æŠ¤è€…**: Solanaåˆçº¦æµ‹è¯•å›¢é˜Ÿ

