# Solana åˆçº¦å­æ¨¡å— - æµ‹è¯•å¥—ä»¶è§„åˆ’

> **æ–‡æ¡£ç‰ˆæœ¬**: v1.0  
> **åˆ›å»ºæ—¥æœŸ**: 2025-11-08  
> **å­æ¨¡å—èŒƒå›´**: Solanaç¨‹åºæµ‹è¯•è§„èŒƒ

---

## ğŸ“‹ ç›®å½•

1. [æµ‹è¯•ç­–ç•¥](#1-æµ‹è¯•ç­–ç•¥)
2. [ç¨‹åºå•å…ƒæµ‹è¯•](#2-ç¨‹åºå•å…ƒæµ‹è¯•)
3. [ç¨‹åºé›†æˆæµ‹è¯•](#3-ç¨‹åºé›†æˆæµ‹è¯•)
4. [è·¨é“¾E2Eæµ‹è¯•](#4-è·¨é“¾e2eæµ‹è¯•)
5. [æµ‹è¯•ç¯å¢ƒé…ç½®](#5-æµ‹è¯•ç¯å¢ƒé…ç½®)

---

## 1. æµ‹è¯•ç­–ç•¥

### 1.1 æµ‹è¯•åˆ†å±‚

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  E2Eæµ‹è¯• (è·¨é“¾å®Œæ•´æµç¨‹)                    â”‚  20%
â”‚  - Solana â†’ Ethereum                      â”‚
â”‚  - Ethereum â†’ Solana                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                 â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  ç¨‹åºé›†æˆæµ‹è¯•                             â”‚  30%
â”‚  - solana-core + token-bridge             â”‚
â”‚  - å¤šæŒ‡ä»¤äº¤äº’                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                 â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  ç¨‹åºå•å…ƒæµ‹è¯•                             â”‚  50%
â”‚  - å„æŒ‡ä»¤ç‹¬ç«‹æµ‹è¯•                         â”‚
â”‚  - è¾¹ç•Œæ¡ä»¶å’Œé”™è¯¯å¤„ç†                     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 1.2 æµ‹è¯•è¦†ç›–ç›®æ ‡

| æµ‹è¯•ç±»å‹ | è¦†ç›–ç‡ç›®æ ‡ | ç”¨ä¾‹æ•° | é¢„è®¡æ—¶é—´ |
|---------|-----------|--------|---------|
| **ç¨‹åºå•å…ƒæµ‹è¯•** | 90%ä»£ç  | 53ä¸ª | 22åˆ†é’Ÿ |
| **é›†æˆæµ‹è¯•** | 80%æµç¨‹ | 6ä¸ª | 10åˆ†é’Ÿ |
| **E2Eæµ‹è¯•** | 100%å…³é”®æµç¨‹ | 7ä¸ª | 20åˆ†é’Ÿ |
| **æ€»è®¡** | - | **66ä¸ª** | **52åˆ†é’Ÿ** |

> **æ³¨**ï¼šå·²å®Œå…¨ç§»é™¤wrapped tokenç›¸å…³æµ‹è¯•ï¼Œé‡‡ç”¨token bindingæ–¹æ¡ˆï¼ˆLock/Unlockæ¨¡å¼ï¼‰

---

## 2. ç¨‹åºå•å…ƒæµ‹è¯•

### 2.1 solana-core å•å…ƒæµ‹è¯•

#### 2.1.1 initializeæŒ‡ä»¤æµ‹è¯•

| æµ‹è¯•ID | æµ‹è¯•åœºæ™¯ | ä¼˜å…ˆçº§ |
|-------|---------|--------|
| UNIT-SC-001 | æ­£å¸¸åˆå§‹åŒ–Bridge | P0 |
| UNIT-SC-002 | åˆå§‹åŒ–Guardian Set | P0 |
| UNIT-SC-003 | è®¾ç½®åˆå§‹message_fee | P0 |
| UNIT-SC-004 | é‡å¤åˆå§‹åŒ–å¤±è´¥ | P0 |

**æµ‹è¯•ç¤ºä¾‹ UNIT-SC-001**:
```rust
#[tokio::test]
async fn test_initialize_bridge() {
    let program = setup_program().await;
    
    // å‡†å¤‡Guardianåˆ—è¡¨
    let guardians = vec![
        guardian_address_1(),
        guardian_address_2(),
        // ... 19ä¸ªGuardian
    ];
    
    // è°ƒç”¨initialize
    let tx = program.methods()
        .initialize(0, guardians.clone(), 1_000_000)
        .accounts({
            bridge: bridge_pda,
            guardian_set: guardian_set_pda,
            payer: payer.pubkey(),
            system_program: system_program::ID,
        })
        .signer(&payer)
        .rpc()
        .await;
    
    assert!(tx.is_ok());
    
    // éªŒè¯Bridgeè´¦æˆ·
    let bridge = program.account::<Bridge>(bridge_pda).await?;
    assert_eq!(bridge.guardian_set_index, 0);
    assert_eq!(bridge.message_fee, 1_000_000);
    assert_eq!(bridge.paused, false);
    
    // éªŒè¯GuardianSetè´¦æˆ·
    let guardian_set = program.account::<GuardianSet>(guardian_set_pda).await?;
    assert_eq!(guardian_set.guardians.len(), 19);
    assert_eq!(guardian_set.guardians, guardians);
}
```

---

#### 2.1.2 post_messageæŒ‡ä»¤æµ‹è¯•

| æµ‹è¯•ID | æµ‹è¯•åœºæ™¯ | ä¼˜å…ˆçº§ |
|-------|---------|--------|
| UNIT-SC-005 | æ­£å¸¸å‘é€æ¶ˆæ¯ | P0 |
| UNIT-SC-006 | åºåˆ—å·é€’å¢ | P0 |
| UNIT-SC-007 | æ‰‹ç»­è´¹ä¸è¶³ | P0 |
| UNIT-SC-008 | payloadå¤§å°é™åˆ¶ | P1 |
| UNIT-SC-009 | Bridgeæš‚åœæ—¶æ‹’ç» | P0 |

**æµ‹è¯•ç¤ºä¾‹ UNIT-SC-005**:
```rust
#[tokio::test]
async fn test_post_message() {
    let program = setup_initialized_program().await;
    
    let payload = vec![1, 2, 3, 4, 5];
    let nonce = 12345u32;
    
    // å‘é€æ¶ˆæ¯
    let tx = program.methods()
        .post_message(nonce, payload.clone(), 32)
        .accounts({
            bridge: bridge_pda,
            message: message_pda,
            emitter: emitter.pubkey(),
            sequence: sequence_pda,
            payer: payer.pubkey(),
            system_program: system_program::ID,
        })
        .signers([&emitter, &payer])
        .rpc()
        .await?;
    
    // éªŒè¯æ¶ˆæ¯è´¦æˆ·
    let message = program.account::<PostedMessage>(message_pda).await?;
    assert_eq!(message.nonce, nonce);
    assert_eq!(message.payload, payload);
    assert_eq!(message.consistency_level, 32);
    assert_eq!(message.sequence, 0);  // ç¬¬ä¸€æ¡æ¶ˆæ¯
    
    // éªŒè¯åºåˆ—å·é€’å¢
    let sequence = program.account::<Sequence>(sequence_pda).await?;
    assert_eq!(sequence.sequence, 1);
}
```

---

#### 2.1.3 post_vaaæŒ‡ä»¤æµ‹è¯•

| æµ‹è¯•ID | æµ‹è¯•åœºæ™¯ | ä¼˜å…ˆçº§ |
|-------|---------|--------|
| UNIT-SC-010 | æ­£å¸¸æ¥æ”¶VAA | P0 |
| UNIT-SC-011 | VAAç­¾åéªŒè¯æˆåŠŸ | P0 |
| UNIT-SC-012 | ç­¾åæ•°é‡ä¸è¶³ï¼ˆ<13ï¼‰ | P0 |
| UNIT-SC-013 | æ— æ•ˆç­¾å | P0 |
| UNIT-SC-014 | Guardian Setè¿‡æœŸ | P0 |
| UNIT-SC-015 | VAAé‡å¤æ¶ˆè´¹ | P0 |
| UNIT-SC-016 | æ— æ•ˆçš„VAAæ ¼å¼ | P1 |

**æµ‹è¯•ç¤ºä¾‹ UNIT-SC-010**:
```rust
#[tokio::test]
async fn test_post_vaa_success() {
    let program = setup_initialized_program().await;
    
    // æ„é€ æµ‹è¯•VAAï¼ˆ13ä¸ªGuardianç­¾åï¼‰
    let vaa = create_test_vaa(
        guardian_set_index: 0,
        emitter_chain: 1,  // Ethereum
        emitter_address: eth_bridge_address,
        sequence: 42,
        payload: token_transfer_payload,
        guardians: &test_guardians[0..13],  // 13ä¸ªç­¾å
    );
    
    // æäº¤VAA
    let tx = program.methods()
        .post_vaa(vaa.clone())
        .accounts({
            bridge: bridge_pda,
            guardian_set: guardian_set_pda,
            posted_vaa: posted_vaa_pda,
            payer: payer.pubkey(),
            system_program: system_program::ID,
        })
        .signer(&payer)
        .rpc()
        .await?;
    
    // éªŒè¯PostedVAAè´¦æˆ·
    let posted_vaa = program.account::<PostedVAA>(posted_vaa_pda).await?;
    assert_eq!(posted_vaa.emitter_chain, 1);
    assert_eq!(posted_vaa.sequence, 42);
    assert_eq!(posted_vaa.consumed, false);
}
```

**æµ‹è¯•ç¤ºä¾‹ UNIT-SC-012**:
```rust
#[tokio::test]
async fn test_post_vaa_insufficient_signatures() {
    let program = setup_initialized_program().await;
    
    // æ„é€ åªæœ‰12ä¸ªç­¾åçš„VAAï¼ˆéœ€è¦13ä¸ªï¼‰
    let vaa = create_test_vaa(
        guardian_set_index: 0,
        guardians: &test_guardians[0..12],  // åªæœ‰12ä¸ªç­¾å
        ...
    );
    
    // åº”è¯¥å¤±è´¥
    let result = program.methods()
        .post_vaa(vaa)
        .accounts({ ... })
        .rpc()
        .await;
    
    assert!(result.is_err());
    assert_eq!(
        result.unwrap_err().to_string(),
        "Insufficient signatures (requires 13/19)"
    );
}
```

---

#### 2.1.4 update_guardian_setæŒ‡ä»¤æµ‹è¯•

| æµ‹è¯•ID | æµ‹è¯•åœºæ™¯ | ä¼˜å…ˆçº§ |
|-------|---------|--------|
| UNIT-SC-017 | æ­£å¸¸å‡çº§Guardian Set | P0 |
| UNIT-SC-018 | æ–°æ—§Setå¹¶å­˜ï¼ˆè¿‡æ¸¡æœŸï¼‰ | P0 |
| UNIT-SC-019 | æ—§Setè¿‡æœŸåæ‹’ç» | P0 |
| UNIT-SC-020 | éæ²»ç†VAAæ‹’ç» | P0 |

**æµ‹è¯•ç¤ºä¾‹ UNIT-SC-017**:
```rust
#[tokio::test]
async fn test_update_guardian_set() {
    let program = setup_initialized_program().await;
    
    // æ„é€ å‡çº§VAAï¼ˆç”±æ—§Guardian Setç­¾åï¼‰
    let new_guardians = generate_new_guardians(19);
    let payload = GuardianSetUpgradePayload {
        module: 0x01,
        action: 0x02,
        chain: 0,
        new_index: 1,
        new_guardians: new_guardians.clone(),
    };
    
    let vaa = create_governance_vaa(
        guardian_set_index: 0,
        payload: payload.serialize(),
        guardians: &current_guardians,
    );
    
    // æ‰§è¡Œå‡çº§
    let tx = program.methods()
        .update_guardian_set(vaa)
        .accounts({
            bridge: bridge_pda,
            current_guardian_set: guardian_set_0_pda,
            new_guardian_set: guardian_set_1_pda,
            payer: payer.pubkey(),
            system_program: system_program::ID,
        })
        .signer(&payer)
        .rpc()
        .await?;
    
    // éªŒè¯Bridgeæ›´æ–°
    let bridge = program.account::<Bridge>(bridge_pda).await?;
    assert_eq!(bridge.guardian_set_index, 1);
    
    // éªŒè¯æ–°Setåˆ›å»º
    let new_set = program.account::<GuardianSet>(guardian_set_1_pda).await?;
    assert_eq!(new_set.index, 1);
    assert_eq!(new_set.guardians, new_guardians);
    assert_eq!(new_set.expiration_time, 0);  // Active
    
    // éªŒè¯æ—§Setè®¾ç½®è¿‡æœŸæ—¶é—´ï¼ˆ7å¤©åï¼‰
    let old_set = program.account::<GuardianSet>(guardian_set_0_pda).await?;
    assert!(old_set.expiration_time > 0);
    assert_eq!(old_set.expiration_time, now + 7 * 86400);
}
```

---

### 2.2 token-bridge å•å…ƒæµ‹è¯•

#### 2.2.1 transfer_tokensæŒ‡ä»¤æµ‹è¯•

| æµ‹è¯•ID | æµ‹è¯•åœºæ™¯ | ä¼˜å…ˆçº§ |
|-------|---------|--------|
| UNIT-TB-001 | æ­£å¸¸é”å®šSPLä»£å¸ï¼ˆ1:1å…‘æ¢ï¼‰ | P0 |
| UNIT-TB-002 | è·¨é“¾å…‘æ¢ä¸åŒä»£å¸ï¼ˆUSDCâ†’USDTï¼‰ | P0 |
| UNIT-TB-003 | TokenBindingä¸å­˜åœ¨å¤±è´¥ | P0 |
| UNIT-TB-004 | TokenBindingæœªå¯ç”¨å¤±è´¥ | P0 |
| UNIT-TB-005 | æˆæƒä¸è¶³ | P0 |
| UNIT-TB-006 | ä½™é¢ä¸è¶³ | P0 |
| UNIT-TB-007 | æ‰‹ç»­è´¹ä¸è¶³ | P0 |
| UNIT-TB-008 | æ— æ•ˆç›®æ ‡é“¾ | P1 |

**æµ‹è¯•ç¤ºä¾‹ UNIT-TB-001: æ­£å¸¸é”å®šSPLä»£å¸ï¼ˆ1:1å…‘æ¢ï¼‰**:
```rust
#[tokio::test]
async fn test_transfer_tokens_one_to_one() {
    let program = setup_token_bridge_program().await;
    
    // åˆ›å»ºæµ‹è¯•ä»£å¸
    let sol_usdc_mint = create_test_mint(&program, 6).await?;
    let user_token_account = create_token_account(&program, &sol_usdc_mint, &user).await?;
    mint_to(&program, &sol_usdc_mint, &user_token_account, 1000_000_000).await?;
    
    // æ³¨å†ŒTokenBindingï¼ˆSolana USDC â†’ Ethereum USDC, 1:1ï¼‰
    let eth_usdc = eth_usdc_address_bytes32();
    register_token_binding(
        &program,
        2, sol_usdc_mint.to_bytes(),
        1, eth_usdc,
        1, 1  // 1:1 rate
    ).await?;
    
    let amount = 500_000_000;  // 500 USDC
    let target_chain = 1;       // Ethereum
    let recipient = eth_address_bytes32();
    
    // æ‰§è¡Œè½¬è´¦
    let tx = program.methods()
        .transfer_tokens(amount, target_chain, recipient)
        .accounts({
            bridge: bridge_pda,
            token_binding: token_binding_pda,
            token_account: user_token_account,
            custody_account: custody_pda,
            token_authority: user.pubkey(),
            token_mint: sol_usdc_mint,
            token_program: token_program::ID,
        })
        .signer(&user)
        .rpc()
        .await?;
    
    // éªŒè¯ä»£å¸é”å®š
    let custody = get_token_account(&program, custody_pda).await?;
    assert_eq!(custody.amount, amount);
    
    // éªŒè¯ç”¨æˆ·ä½™é¢å‡å°‘
    let user_account = get_token_account(&program, user_token_account).await?;
    assert_eq!(user_account.amount, 500_000_000);
    
    // éªŒè¯æ¶ˆæ¯å‘é€
    let sequence = program.account::<Sequence>(sequence_pda).await?;
    assert_eq!(sequence.sequence, 1);
    
    // éªŒè¯payloadåŒ…å«å…‘æ¢ä¿¡æ¯
    let message = program.account::<PostedMessage>(message_pda).await?;
    let payload = TokenTransferPayload::deserialize(&message.payload)?;
    assert_eq!(payload.amount, 500_000_000);
    assert_eq!(payload.target_token, eth_usdc);
    assert_eq!(payload.target_amount, 500_000_000);  // 1:1
    assert_eq!(payload.exchange_rate_num, 1);
    assert_eq!(payload.exchange_rate_denom, 1);
}
```

**æµ‹è¯•ç¤ºä¾‹ UNIT-TB-002: è·¨é“¾å…‘æ¢ä¸åŒä»£å¸**:
```rust
#[tokio::test]
async fn test_transfer_tokens_with_exchange() {
    let program = setup_token_bridge_program().await;
    
    // Solana USDC â†’ Ethereum USDT (1:0.998å…‘æ¢)
    let sol_usdc_mint = create_test_mint(&program, 6).await?;
    let user_token_account = create_token_account(&program, &sol_usdc_mint, &user).await?;
    mint_to(&program, &sol_usdc_mint, &user_token_account, 1000_000_000).await?;
    
    // æ³¨å†ŒTokenBindingï¼ˆUSDC â†’ USDT, 998:1000ï¼‰
    let eth_usdt = eth_usdt_address_bytes32();
    register_token_binding(
        &program,
        2, sol_usdc_mint.to_bytes(),
        1, eth_usdt,
        998, 1000  // 1 USDC = 0.998 USDT
    ).await?;
    
    let amount = 1000_000_000;  // 1000 USDC
    
    // æ‰§è¡Œè½¬è´¦
    let tx = program.methods()
        .transfer_tokens(amount, 1, eth_recipient)
        .accounts({ ... })
        .rpc()
        .await?;
    
    // éªŒè¯payload
    let message = program.account::<PostedMessage>(message_pda).await?;
    let payload = TokenTransferPayload::deserialize(&message.payload)?;
    assert_eq!(payload.amount, 1000_000_000);  // æºé“¾1000 USDC
    assert_eq!(payload.target_token, eth_usdt);  // ç›®æ ‡æ˜¯USDT
    assert_eq!(payload.target_amount, 998_000_000);  // ç›®æ ‡é“¾998 USDT
    assert_eq!(payload.exchange_rate_num, 998);
    assert_eq!(payload.exchange_rate_denom, 1000);
}
```

**æµ‹è¯•ç¤ºä¾‹ UNIT-TB-003: TokenBindingä¸å­˜åœ¨å¤±è´¥**:
```rust
#[tokio::test]
async fn test_transfer_tokens_no_binding() {
    let program = setup_token_bridge_program().await;
    
    // æœªæ³¨å†ŒTokenBindingçš„ä»£å¸
    let unknown_mint = create_test_mint(&program, 6).await?;
    
    let result = program.methods()
        .transfer_tokens(1000_000_000, 1, eth_recipient)
        .accounts({
            token_binding: token_binding_pda,  // PDAä¸å­˜åœ¨
            ...
        })
        .rpc()
        .await;
    
    assert!(result.is_err());
    assert_eq!(
        result.unwrap_err().to_string(),
        "Token binding not found"
    );
}
```

---

#### 2.2.2 complete_transferæŒ‡ä»¤æµ‹è¯•

| æµ‹è¯•ID | æµ‹è¯•åœºæ™¯ | ä¼˜å…ˆçº§ |
|-------|---------|--------|
| UNIT-TB-009 | è§£é”åŸç”ŸSPLä»£å¸ï¼ˆ1:1å…‘æ¢ï¼‰ | P0 |
| UNIT-TB-010 | è·¨é“¾å…‘æ¢ä¸åŒä»£å¸æ¥æ”¶ | P0 |
| UNIT-TB-025 | å…‘æ¢æ¯”ç‡éªŒè¯å¤±è´¥ | P0 |
| UNIT-TB-026 | ç›®æ ‡ä»£å¸ä¸åŒ¹é… | P0 |
| UNIT-TB-027 | VAAéªŒè¯å¤±è´¥ | P0 |
| UNIT-TB-028 | ç›®æ ‡é“¾ä¸åŒ¹é… | P0 |
| UNIT-TB-029 | custodyä½™é¢ä¸è¶³ | P0 |

**æµ‹è¯•ç¤ºä¾‹ UNIT-TB-009: è§£é”åŸç”ŸSPLä»£å¸ï¼ˆ1:1å…‘æ¢ï¼‰**:
```rust
#[tokio::test]
async fn test_complete_transfer_unlock_one_to_one() {
    let program = setup_token_bridge_program().await;
    
    // é¢„å…ˆåœ¨custodyé”å®šä»£å¸
    let sol_usdc_mint = create_test_mint(&program, 6).await?;
    let custody_amount = 1000_000_000;
    setup_custody_balance(&program, &sol_usdc_mint, custody_amount).await?;
    
    // æ³¨å†ŒTokenBindingï¼ˆEthereum USDC â†’ Solana USDC, 1:1ï¼‰
    let eth_usdc = eth_usdc_address_bytes32();
    register_token_binding(
        &program,
        1, eth_usdc,  // Ethereum USDC
        2, sol_usdc_mint.to_bytes(),  // Solana USDC
        1, 1  // 1:1
    ).await?;
    
    // æ„é€ æ¥è‡ªEthereumçš„è½¬è´¦VAA
    let payload = TokenTransferPayload {
        payload_type: 1,
        amount: 500_000_000,  // æºé“¾500 USDC
        token_address: eth_usdc,
        token_chain: 1,  // Ethereum
        recipient: user.pubkey().to_bytes(),
        recipient_chain: 2,  // Solana
        // æ–°å¢å…‘æ¢å­—æ®µ
        target_token: sol_usdc_mint.to_bytes(),
        target_amount: 500_000_000,  // ç›®æ ‡é“¾500 USDC (1:1)
        exchange_rate_num: 1,
        exchange_rate_denom: 1,
    };
    
    let vaa = create_token_transfer_vaa(
        emitter_chain: 1,  // Ethereum
        payload: payload.serialize(),
        guardians: &test_guardians[0..13],
    );
    
    // å®Œæˆè½¬è´¦
    let tx = program.methods()
        .complete_transfer(vaa)
        .accounts({
            bridge: bridge_pda,
            posted_vaa: posted_vaa_pda,
            token_binding: token_binding_pda,
            recipient_account: user_token_account,
            custody_account: custody_pda,
            target_token_mint: sol_usdc_mint,
            token_program: token_program::ID,
        })
        .rpc()
        .await?;
    
    // éªŒè¯ç”¨æˆ·æ”¶åˆ°ä»£å¸
    let user_account = get_token_account(&program, user_token_account).await?;
    assert_eq!(user_account.amount, 500_000_000);
    
    // éªŒè¯custodyå‡å°‘
    let custody = get_token_account(&program, custody_pda).await?;
    assert_eq!(custody.amount, 500_000_000);
    
    // éªŒè¯VAAæ ‡è®°ä¸ºå·²æ¶ˆè´¹
    let posted_vaa = program.account::<PostedVAA>(posted_vaa_pda).await?;
    assert_eq!(posted_vaa.consumed, true);
}
```

**æµ‹è¯•ç¤ºä¾‹ UNIT-TB-010: è·¨é“¾å…‘æ¢ä¸åŒä»£å¸æ¥æ”¶**:
```rust
#[tokio::test]
async fn test_complete_transfer_different_token() {
    let program = setup_token_bridge_program().await;
    
    // Ethereum USDT â†’ Solana USDC (1:1.002å…‘æ¢ï¼ŒUSDTç¨ä¾¿å®œ)
    let sol_usdc_mint = create_test_mint(&program, 6).await?;
    setup_custody_balance(&program, &sol_usdc_mint, 2000_000_000).await?;
    
    let eth_usdt = eth_usdt_address_bytes32();
    register_token_binding(
        &program,
        1, eth_usdt,  // Ethereum USDT
        2, sol_usdc_mint.to_bytes(),  // Solana USDC
        1002, 1000  // 1 USDT = 1.002 USDC
    ).await?;
    
    // VAA payload
    let payload = TokenTransferPayload {
        payload_type: 1,
        amount: 1000_000_000,  // 1000 USDT
        token_address: eth_usdt,
        token_chain: 1,
        recipient: user.pubkey().to_bytes(),
        recipient_chain: 2,
        target_token: sol_usdc_mint.to_bytes(),
        target_amount: 1_002_000_000,  // 1002 USDC
        exchange_rate_num: 1002,
        exchange_rate_denom: 1000,
    };
    
    let vaa = create_token_transfer_vaa(
        emitter_chain: 1,
        payload: payload.serialize(),
        guardians: &test_guardians[0..13],
    );
    
    // å®Œæˆè½¬è´¦
    let tx = program.methods()
        .complete_transfer(vaa)
        .accounts({ ... })
        .rpc()
        .await?;
    
    // éªŒè¯ç”¨æˆ·æ”¶åˆ°å…‘æ¢åçš„ä»£å¸
    let user_account = get_token_account(&program, user_token_account).await?;
    assert_eq!(user_account.amount, 1_002_000_000);  // 1002 USDC
}
```

**æµ‹è¯•ç¤ºä¾‹ UNIT-TB-025: å…‘æ¢æ¯”ç‡éªŒè¯å¤±è´¥**:
```rust
#[tokio::test]
async fn test_complete_transfer_invalid_exchange_rate() {
    let program = setup_token_bridge_program().await;
    
    // æ³¨å†Œ1:1å…‘æ¢æ¯”ç‡
    register_token_binding(&program, 1, eth_usdc, 2, sol_usdc, 1, 1).await?;
    
    // VAAåŒ…å«é”™è¯¯çš„å…‘æ¢æ¯”ç‡
    let payload = TokenTransferPayload {
        amount: 1000_000_000,
        target_amount: 1100_000_000,  // é”™è¯¯ï¼šå£°ç§°1:1.1
        exchange_rate_num: 11,  // é”™è¯¯çš„æ¯”ç‡
        exchange_rate_denom: 10,
        ...
    };
    
    let vaa = create_token_transfer_vaa(...);
    
    let result = program.methods()
        .complete_transfer(vaa)
        .accounts({ ... })
        .rpc()
        .await;
    
    assert!(result.is_err());
    assert_eq!(
        result.unwrap_err().to_string(),
        "Invalid exchange rate"
    );
}
```

---

#### 2.2.3 register_token_bindingæŒ‡ä»¤æµ‹è¯•

| æµ‹è¯•ID | æµ‹è¯•åœºæ™¯ | ä¼˜å…ˆçº§ |
|-------|---------|--------|
| UNIT-TB-011 | æ­£å¸¸æ³¨å†Œå•å‘ä»£å¸ç»‘å®š | P0 |
| UNIT-TB-012 | é‡å¤æ³¨å†Œå¤±è´¥ | P0 |
| UNIT-TB-013 | éç®¡ç†å‘˜è°ƒç”¨å¤±è´¥ | P0 |
| UNIT-TB-014 | æ³¨å†Œä¸åŒä»£å¸å…‘æ¢å¯¹ï¼ˆå¤šå¯¹å¤šï¼‰ | P0 |
| UNIT-TB-030 | æ³¨å†Œå‡ºç«™å’Œå…¥ç«™bindingï¼ˆåŒå‘ï¼‰ | P0 |

#### 2.2.4 register_bidirectional_bindingæŒ‡ä»¤æµ‹è¯•

| æµ‹è¯•ID | æµ‹è¯•åœºæ™¯ | ä¼˜å…ˆçº§ |
|-------|---------|--------|
| UNIT-TB-031 | åŒå‘æ³¨å†ŒåŒå¸ç§ï¼ˆ1:1ï¼‰ | P0 |
| UNIT-TB-032 | åŒå‘æ³¨å†Œä¸åŒå¸ç§ | P0 |
| UNIT-TB-033 | åŒå‘ä¸å¯¹ç§°å…‘æ¢æ¯”ç‡ | P0 |
| UNIT-TB-034 | éªŒè¯è‡ªåŠ¨åˆ›å»ºä¸¤ä¸ªbinding | P0 |
| UNIT-TB-035 | éç®¡ç†å‘˜è°ƒç”¨å¤±è´¥ | P0 |

#### 2.2.5 set_exchange_rateæŒ‡ä»¤æµ‹è¯•

| æµ‹è¯•ID | æµ‹è¯•åœºæ™¯ | ä¼˜å…ˆçº§ |
|-------|---------|--------|
| UNIT-TB-015 | è®¾ç½®1:1å…‘æ¢æ¯”ç‡ | P0 |
| UNIT-TB-016 | è®¾ç½®è‡ªå®šä¹‰å…‘æ¢æ¯”ç‡ | P0 |
| UNIT-TB-017 | åˆ†æ¯ä¸º0å¤±è´¥ | P0 |
| UNIT-TB-018 | TokenBindingä¸å­˜åœ¨å¤±è´¥ | P0 |
| UNIT-TB-019 | éç®¡ç†å‘˜è°ƒç”¨å¤±è´¥ | P0 |

#### 2.2.6 update_amm_configæŒ‡ä»¤æµ‹è¯•

| æµ‹è¯•ID | æµ‹è¯•åœºæ™¯ | ä¼˜å…ˆçº§ |
|-------|---------|--------|
| UNIT-TB-020 | å¯ç”¨å¤–éƒ¨AMMå®šä»· | P1 |
| UNIT-TB-021 | ç¦ç”¨å¤–éƒ¨AMMå®šä»· | P1 |
| UNIT-TB-022 | éç®¡ç†å‘˜è°ƒç”¨å¤±è´¥ | P1 |

---

**æµ‹è¯•ç¤ºä¾‹ UNIT-TB-011: æ­£å¸¸æ³¨å†Œä»£å¸ç»‘å®š**:
```rust
#[tokio::test]
async fn test_register_token_binding() {
    let program = setup_token_bridge_program().await;
    
    // Ethereum USDCåœ°å€
    let eth_usdc = [0xA0, 0xb8, 0x69, 0x91, ...];  // 32å­—èŠ‚
    
    // Solana USDC Mint
    let sol_usdc = Pubkey::from_str("EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v").unwrap();
    
    let tx = program.methods()
        .register_token_binding(
            1,  // source_chain: Ethereum
            eth_usdc,
            2,  // target_chain: Solana
            sol_usdc
        )
        .accounts({
            bridge_config: bridge_config_pda,
            token_binding: token_binding_pda,
            authority: authority.pubkey(),
            payer: payer.pubkey(),
            system_program: system_program::ID,
        })
        .signers([&authority, &payer])
        .rpc()
        .await?;
    
    // éªŒè¯TokenBindingè´¦æˆ·
    let binding = program.account::<TokenBinding>(token_binding_pda).await?;
    assert_eq!(binding.source_chain, 1);
    assert_eq!(binding.source_token, eth_usdc);
    assert_eq!(binding.target_chain, 2);
    assert_eq!(binding.target_token, sol_usdc.to_bytes());
    assert_eq!(binding.rate_numerator, 1);  // é»˜è®¤1:1
    assert_eq!(binding.rate_denominator, 1);
    assert_eq!(binding.enabled, true);
    assert_eq!(binding.use_external_price, false);
}
```

**æµ‹è¯•ç¤ºä¾‹ UNIT-TB-014: æ³¨å†Œä¸åŒä»£å¸å…‘æ¢å¯¹ï¼ˆå¤šå¯¹å¤šï¼‰**:
```rust
#[tokio::test]
async fn test_register_multiple_target_tokens() {
    let program = setup_token_bridge_program().await;
    
    let sol_usdc = sol_usdc_address();
    let eth_usdc = eth_usdc_address();
    let eth_usdt = eth_usdt_address();
    let eth_dai = eth_dai_address();
    
    // åŒä¸€æºä»£å¸æ³¨å†Œå¤šä¸ªç›®æ ‡ä»£å¸
    // Solana USDC â†’ Ethereum USDC
    register_token_binding(&program, 2, sol_usdc, 1, eth_usdc).await?;
    
    // Solana USDC â†’ Ethereum USDT
    register_token_binding(&program, 2, sol_usdc, 1, eth_usdt).await?;
    
    // Solana USDC â†’ Ethereum DAI
    register_token_binding(&program, 2, sol_usdc, 1, eth_dai).await?;
    
    // éªŒè¯æ‰€æœ‰bindingéƒ½å­˜åœ¨
    let binding_usdc = get_token_binding(&program, 2, sol_usdc, 1, eth_usdc).await?;
    assert_eq!(binding_usdc.target_token, eth_usdc);
    
    let binding_usdt = get_token_binding(&program, 2, sol_usdc, 1, eth_usdt).await?;
    assert_eq!(binding_usdt.target_token, eth_usdt);
    
    let binding_dai = get_token_binding(&program, 2, sol_usdc, 1, eth_dai).await?;
    assert_eq!(binding_dai.target_token, eth_dai);
}
```

**æµ‹è¯•ç¤ºä¾‹ UNIT-TB-030: æ³¨å†Œå‡ºç«™å’Œå…¥ç«™bindingï¼ˆåŒå‘ï¼‰**:
```rust
#[tokio::test]
async fn test_register_outbound_and_inbound_bindings() {
    let program = setup_token_bridge_program().await;
    
    // åœ¨Solanaé“¾ä¸Šæ³¨å†ŒåŒå‘binding
    // 1. å‡ºç«™: Solana USDC â†’ Ethereum USDC
    register_token_binding(&program, 2, sol_usdc, 1, eth_usdc).await?;
    
    // 2. å…¥ç«™: Ethereum USDC â†’ Solana USDC (ç”¨äºéªŒè¯)
    register_token_binding(&program, 1, eth_usdc, 2, sol_usdc).await?;
    
    // éªŒè¯å‡ºç«™binding
    let outbound = get_token_binding(&program, 2, sol_usdc, 1, eth_usdc).await?;
    assert_eq!(outbound.source_chain, 2);
    assert_eq!(outbound.target_chain, 1);
    
    // éªŒè¯å…¥ç«™binding
    let inbound = get_token_binding(&program, 1, eth_usdc, 2, sol_usdc).await?;
    assert_eq!(inbound.source_chain, 1);
    assert_eq!(inbound.target_chain, 2);
}
```

---

**æµ‹è¯•ç¤ºä¾‹ UNIT-TB-031: åŒå‘æ³¨å†ŒåŒå¸ç§ï¼ˆ1:1ï¼‰**:
```rust
#[tokio::test]
async fn test_register_bidirectional_same_token() {
    let program = setup_token_bridge_program().await;
    
    let tx = program.methods()
        .register_bidirectional_binding(
            2, sol_usdc,      // local
            1, eth_usdc,      // remote
            1, 1,             // outbound rate 1:1
            1, 1,             // inbound rate 1:1
        )
        .accounts({
            bridge_config: bridge_config_pda,
            outbound_binding: outbound_pda,
            inbound_binding: inbound_pda,
            authority: authority.pubkey(),
            payer: payer.pubkey(),
            system_program: system_program::ID,
        })
        .signers([&authority, &payer])
        .rpc()
        .await?;
    
    // éªŒè¯å‡ºç«™binding
    let outbound = program.account::<TokenBinding>(outbound_pda).await?;
    assert_eq!(outbound.source_chain, 2);
    assert_eq!(outbound.source_token, sol_usdc);
    assert_eq!(outbound.target_chain, 1);
    assert_eq!(outbound.target_token, eth_usdc);
    assert_eq!(outbound.rate_numerator, 1);
    assert_eq!(outbound.rate_denominator, 1);
    
    // éªŒè¯å…¥ç«™binding
    let inbound = program.account::<TokenBinding>(inbound_pda).await?;
    assert_eq!(inbound.source_chain, 1);
    assert_eq!(inbound.source_token, eth_usdc);
    assert_eq!(inbound.target_chain, 2);
    assert_eq!(inbound.target_token, sol_usdc);
    assert_eq!(inbound.rate_numerator, 1);
    assert_eq!(inbound.rate_denominator, 1);
}
```

**æµ‹è¯•ç¤ºä¾‹ UNIT-TB-033: åŒå‘ä¸å¯¹ç§°å…‘æ¢æ¯”ç‡**:
```rust
#[tokio::test]
async fn test_register_bidirectional_asymmetric_rates() {
    let program = setup_token_bridge_program().await;
    
    // å‡ºç«™å’Œå…¥ç«™ä½¿ç”¨ä¸åŒçš„å…‘æ¢æ¯”ç‡ï¼ˆè€ƒè™‘æ‰‹ç»­è´¹ç­‰ï¼‰
    let tx = program.methods()
        .register_bidirectional_binding(
            2, sol_usdc,
            1, eth_usdt,
            998, 1000,  // å‡ºç«™: 1 USDC = 0.998 USDT
            1002, 1000, // å…¥ç«™: 1 USDT = 1.002 USDC (è¡¥å¿)
        )
        .accounts({ ... })
        .rpc()
        .await?;
    
    let outbound = program.account::<TokenBinding>(outbound_pda).await?;
    assert_eq!(outbound.rate_numerator, 998);
    assert_eq!(outbound.rate_denominator, 1000);
    
    let inbound = program.account::<TokenBinding>(inbound_pda).await?;
    assert_eq!(inbound.rate_numerator, 1002);
    assert_eq!(inbound.rate_denominator, 1000);
    
    // éªŒè¯å…‘æ¢è®¡ç®—
    let outbound_amount = 1000_000_000 * 998 / 1000;
    assert_eq!(outbound_amount, 998_000_000);  // 0.998
    
    let inbound_amount = 1000_000_000 * 1002 / 1000;
    assert_eq!(inbound_amount, 1_002_000_000);  // 1.002
}
```

**æµ‹è¯•ç¤ºä¾‹ UNIT-TB-015: è®¾ç½®1:1å…‘æ¢æ¯”ç‡**:
```rust
#[tokio::test]
async fn test_set_exchange_rate_one_to_one() {
    let program = setup_token_bridge_program().await;
    
    // å…ˆæ³¨å†ŒTokenBinding
    register_token_binding(&program, sol_usdc, eth_usdc).await?;
    
    // è®¾ç½®å…‘æ¢æ¯”ç‡
    let tx = program.methods()
        .set_exchange_rate(
            2,  // Solana
            sol_usdc.to_bytes(),
            1,  // Ethereum
            1,  // rate_numerator
            1   // rate_denominator
        )
        .accounts({
            token_binding: token_binding_pda,
            authority: authority.pubkey(),
        })
        .signer(&authority)
        .rpc()
        .await?;
    
    let binding = program.account::<TokenBinding>(token_binding_pda).await?;
    assert_eq!(binding.rate_numerator, 1);
    assert_eq!(binding.rate_denominator, 1);
    
    // éªŒè¯å…‘æ¢è®¡ç®—
    let source_amount = 1000_000_000u64;
    let target_amount = source_amount * binding.rate_numerator / binding.rate_denominator;
    assert_eq!(target_amount, 1000_000_000u64);  // 1:1
}
```

**æµ‹è¯•ç¤ºä¾‹ UNIT-TB-016: è®¾ç½®è‡ªå®šä¹‰å…‘æ¢æ¯”ç‡**:
```rust
#[tokio::test]
async fn test_set_custom_exchange_rate() {
    let program = setup_token_bridge_program().await;
    
    // è®¾ç½® 1 USDC = 0.998 USDT
    let tx = program.methods()
        .set_exchange_rate(
            2,    // Solana
            sol_usdc.to_bytes(),
            1,    // Ethereum
            998,  // rate_numerator
            1000  // rate_denominator
        )
        .accounts({ ... })
        .rpc()
        .await?;
    
    let binding = program.account::<TokenBinding>(token_binding_pda).await?;
    assert_eq!(binding.rate_numerator, 998);
    assert_eq!(binding.rate_denominator, 1000);
    
    // éªŒè¯å…‘æ¢è®¡ç®—
    let source_amount = 1000_000_000u64;  // 1000 USDC
    let target_amount = source_amount * 998 / 1000;
    assert_eq!(target_amount, 998_000_000u64);  // 998 USDT
}
```

**æµ‹è¯•ç¤ºä¾‹ UNIT-TB-017: åˆ†æ¯ä¸º0å¤±è´¥**:
```rust
#[tokio::test]
async fn test_set_exchange_rate_zero_denominator() {
    let program = setup_token_bridge_program().await;
    
    let result = program.methods()
        .set_exchange_rate(2, sol_usdc.to_bytes(), 1, 1, 0)  // åˆ†æ¯=0
        .accounts({ ... })
        .rpc()
        .await;
    
    assert!(result.is_err());
    assert_eq!(
        result.unwrap_err().to_string(),
        "Exchange rate denominator cannot be zero"
    );
}
```

---

## 3. ç¨‹åºé›†æˆæµ‹è¯•

### 3.1 è·¨ç¨‹åºè°ƒç”¨æµ‹è¯•

| æµ‹è¯•ID | æµ‹è¯•åœºæ™¯ | ä¼˜å…ˆçº§ |
|-------|---------|--------|
| INT-SOL-001 | transfer_tokens â†’ post_message | P0 |
| INT-SOL-002 | post_vaa â†’ complete_transfer | P0 |
| INT-SOL-003 | å¤šæ­¥éª¤åŸå­æ€§ | P0 |

**æµ‹è¯•ç¤ºä¾‹ INT-SOL-001**:
```rust
#[tokio::test]
async fn test_transfer_posts_message() {
    let (core_program, token_program) = setup_both_programs().await;
    
    // æ‰§è¡Œtransfer_tokens
    let tx = token_program.methods()
        .transfer_tokens(1000_000_000, 1, eth_recipient)
        .accounts({ ... })
        .rpc()
        .await?;
    
    // éªŒè¯post_messageè¢«è°ƒç”¨
    let sequence = core_program.account::<Sequence>(sequence_pda).await?;
    assert_eq!(sequence.sequence, 1);
    
    // éªŒè¯æ¶ˆæ¯å†…å®¹
    let message = core_program.account::<PostedMessage>(message_pda).await?;
    let payload = TokenTransferPayload::deserialize(&message.payload)?;
    assert_eq!(payload.amount, 1000_000_000);
    assert_eq!(payload.recipient_chain, 1);
}
```

---

### 3.2 Guardian Setå‡çº§æµ‹è¯•

| æµ‹è¯•ID | æµ‹è¯•åœºæ™¯ | ä¼˜å…ˆçº§ |
|-------|---------|--------|
| INT-SOL-004 | å‡çº§åæ—§Setä»å¯éªŒè¯ | P0 |
| INT-SOL-005 | å‡çº§åæ–°Setå¯éªŒè¯ | P0 |
| INT-SOL-006 | è¿‡æœŸåæ—§Setæ‹’ç» | P0 |

**æµ‹è¯•ç¤ºä¾‹ INT-SOL-004**:
```rust
#[tokio::test]
async fn test_guardian_upgrade_transition() {
    let program = setup_initialized_program().await;
    
    // 1. å‡çº§Guardian Set
    upgrade_guardian_set(&program, new_guardians).await?;
    
    // 2. æµ‹è¯•æ—§Setç­¾åçš„VAAï¼ˆè¿‡æ¸¡æœŸå†…ï¼‰
    let vaa_old = create_test_vaa(
        guardian_set_index: 0,  // æ—§Set
        guardians: &old_guardians[0..13],
        ...
    );
    
    let result = program.methods()
        .post_vaa(vaa_old)
        .accounts({ ... })
        .rpc()
        .await;
    
    assert!(result.is_ok());  // è¿‡æ¸¡æœŸå†…æ—§Setæœ‰æ•ˆ
    
    // 3. æµ‹è¯•æ–°Setç­¾åçš„VAA
    let vaa_new = create_test_vaa(
        guardian_set_index: 1,  // æ–°Set
        guardians: &new_guardians[0..13],
        ...
    );
    
    let result = program.methods()
        .post_vaa(vaa_new)
        .accounts({ ... })
        .rpc()
        .await;
    
    assert!(result.is_ok());  // æ–°Setä¹Ÿæœ‰æ•ˆ
    
    // 4. 7å¤©åæµ‹è¯•æ—§Setï¼ˆåº”å¤±è´¥ï¼‰
    advance_time(7 * 86400 + 1).await;
    
    let vaa_old_expired = create_test_vaa(
        guardian_set_index: 0,
        guardians: &old_guardians[0..13],
        ...
    );
    
    let result = program.methods()
        .post_vaa(vaa_old_expired)
        .accounts({ ... })
        .rpc()
        .await;
    
    assert!(result.is_err());  // æ—§Setå·²è¿‡æœŸ
    assert_eq!(result.unwrap_err().to_string(), "Guardian set expired");
}
```

---

## 4. è·¨é“¾E2Eæµ‹è¯•

### 4.1 Solana â†’ Ethereum

| æµ‹è¯•ID | æµ‹è¯•åœºæ™¯ | ä¼˜å…ˆçº§ | é¢„è®¡æ—¶é—´ |
|-------|---------|--------|---------|
| E2E-SOL-001 | SPLä»£å¸è·¨é“¾åˆ°Ethereum | P0 | 2åˆ†é’Ÿ |
| E2E-SOL-002 | Ethereumè§£é”åŸç”ŸERC20 | P0 | 1åˆ†é’Ÿ |

**æµ‹è¯•ç¤ºä¾‹ E2E-SOL-001**:
```typescript
// E2Eæµ‹è¯•è„šæœ¬
describe("Solana to Ethereum Transfer", () => {
  it("should transfer SPL token and receive ERC20", async () => {
    // 1. Solana: é”å®šSPLä»£å¸
    const tx = await tokenBridge.methods
      .transferTokens(
        new BN(1000_000_000),  // 1000 USDC
        1,                      // Target chain: Ethereum
        ethRecipient
      )
      .rpc();
    
    console.log("Solana TX:", tx);
    
    // 2. ç­‰å¾…Guardianç­¾å
    const sequence = await getSequenceNumber(tx);
    const vaa = await pollGuardianForVAA({
      emitterChain: 2,
      emitterAddress: tokenBridgeProgramId,
      sequence: sequence,
    });
    
    assert(vaa.signatures.length >= 13);
    
    // 3. Relayeræäº¤åˆ°Ethereum
    const ethTx = await ethBridgeCore.receiveMessage(vaa);
    await ethTx.wait();
    
    // 4. éªŒè¯Ethereumä½™é¢
    const balance = await ethUSDC.balanceOf(ethRecipient);
    expect(balance).to.equal(ethers.utils.parseUnits("1000", 6));
  });
});
```

---

### 4.2 Ethereum â†’ Solana

| æµ‹è¯•ID | æµ‹è¯•åœºæ™¯ | ä¼˜å…ˆçº§ | é¢„è®¡æ—¶é—´ |
|-------|---------|--------|---------|
| E2E-SOL-003 | ERC20è·¨é“¾åˆ°Solanaè§£é”ç»‘å®šSPL | P0 | 2åˆ†é’Ÿ |

**æµ‹è¯•ç¤ºä¾‹ E2E-SOL-003**:
```typescript
describe("Ethereum to Solana Transfer", () => {
  it("should lock ERC20 and unlock bound SPL token", async () => {
    // å‰æï¼šå·²é€šè¿‡register_token_bindingæ³¨å†Œbindingå…³ç³»
    // [1, eth_usdc, 900, sol_usdc] å·²åœ¨Ethereumå’ŒSolanaä¸¤ç«¯æ³¨å†Œ
    
    // 1. Ethereum: é”å®šERC20
    const tx = await ethTokenVault.lockTokens(
      ethUSDC.address,
      ethers.utils.parseUnits("1000", 6),
      2,  // Target chain: Solana
      solanaRecipient
    );
    await tx.wait();
    
    // 2. è·å–VAA
    const sequence = await extractSequence(tx);
    const vaa = await pollGuardianForVAA({
      emitterChain: 1,
      emitterAddress: ethTokenVault.address,
      sequence: sequence,
    });
    
    // 3. Solana: post_vaa
    const postVaaTx = await solanaCore.methods
      .postVaa(vaa)
      .rpc();
    
    // 4. Solana: complete_transfer (åŸºäºbindingè§£é”å·²æœ‰SPLä»£å¸)
    const completeTx = await tokenBridge.methods
      .completeTransfer(vaa)
      .rpc();
    
    // 5. éªŒè¯Solanaä½™é¢ (è§£é”çš„æ˜¯åŸç”ŸSPL USDCï¼Œä¸æ˜¯wrapped token)
    const account = await getAccount(
      connection,
      solanaRecipientTokenAccount
    );
    expect(account.amount).to.equal(1000_000_000n);
  });
});
```

---

### 4.3 Guardianå‡çº§è·¨é“¾æµ‹è¯•

| æµ‹è¯•ID | æµ‹è¯•åœºæ™¯ | ä¼˜å…ˆçº§ | é¢„è®¡æ—¶é—´ |
|-------|---------|--------|---------|
| E2E-SOL-005 | Solana Guardianå‡çº§åŸå­æ€§ | P0 | 5åˆ†é’Ÿ |

**æµ‹è¯•æµç¨‹**:
```
1. åœ¨Ethereumå‡çº§Guardian Set
2. ç­‰å¾…VAAç”Ÿæˆ
3. åœ¨Solanaæäº¤å‡çº§VAA
4. éªŒè¯ä¸¤æ¡é“¾Guardian SetåŒæ­¥
5. æµ‹è¯•è¿‡æ¸¡æœŸå†…è·¨é“¾æ¶ˆæ¯
6. éªŒè¯æ–°æ—§Setéƒ½èƒ½å·¥ä½œ
```

---

### 4.4 å®Œæ•´è·¨é“¾æµç¨‹æµ‹è¯•

| æµ‹è¯•ID | æµ‹è¯•åœºæ™¯ | ä¼˜å…ˆçº§ | é¢„è®¡æ—¶é—´ |
|-------|---------|--------|---------|
| E2E-SOL-006 | å®Œæ•´å¾€è¿”æµ‹è¯• (Solanaâ†’Ethereumâ†’Solana) | P1 | 5åˆ†é’Ÿ |
| E2E-SOL-007 | å¤šç”¨æˆ·å¹¶å‘è·¨é“¾æµ‹è¯• | P1 | 3åˆ†é’Ÿ |
| E2E-SOL-008 | å‹åŠ›æµ‹è¯• - å¤§é¢è½¬è´¦ | P2 | 2åˆ†é’Ÿ |

**æµ‹è¯•ç¤ºä¾‹ E2E-SOL-006**:
```typescript
describe("å®Œæ•´å¾€è¿”æµ‹è¯•", () => {
  it("should complete round trip: Solanaâ†’Ethereumâ†’Solana", async () => {
    // 1. Solana: é”å®š1000 USDCå‘å¾€Ethereum
    await tokenBridge.methods
      .transferTokens(
        new BN(1000_000_000),
        ETH_CHAIN_ID,
        ethUsdcAddress,
        ethRecipient
      )
      .rpc();
    
    // 2. éªŒè¯Solanaä»£å¸å·²é”å®š
    const custodyBalance1 = await getTokenBalance(connection, custodyAccount);
    expect(custodyBalance1).to.equal(1000_000_000n);
    
    // 3. æ¨¡æ‹ŸEthereumè§£é”å¹¶è¿”å›500 USDCåˆ°Solana
    const returnVaa = createTokenTransferVAA({
      emitterChain: ETH_CHAIN_ID,
      transferPayload: {
        amount: BigInt(500_000_000),
        tokenAddress: ethUsdcAddress,
        recipient: alicePublicKey.toBuffer(),
        targetToken: solUsdcMint.toBuffer(),
        // ...
      }
    });
    
    // 4. Solana: æ¥æ”¶è¿”å›çš„ä»£å¸
    await coreProgram.methods.postVaa(returnVaa).rpc();
    await tokenBridge.methods.completeTransfer(returnVaa).rpc();
    
    // 5. éªŒè¯Aliceæ”¶åˆ°500 USDC
    const aliceBalance = await getTokenBalance(connection, aliceTokenAccount);
    expect(aliceBalance).to.equal(500_000_000n);
  });
});
```

**æµ‹è¯•ç¤ºä¾‹ E2E-SOL-007**:
```typescript
describe("å¤šç”¨æˆ·å¹¶å‘æµ‹è¯•", () => {
  it("should handle concurrent transfers from multiple users", async () => {
    // 1. åˆ›å»º3ä¸ªç”¨æˆ·ï¼Œæ¯äºº5000 USDC
    const users = [];
    for (let i = 0; i < 3; i++) {
      const user = Keypair.generate();
      const userAccount = await createAndMintTestToken(
        connection, payer, solUsdcMint, user.publicKey,
        BigInt(5000_000_000)
      );
      users.push({ keypair: user, account: userAccount });
    }
    
    // 2. æ‰€æœ‰ç”¨æˆ·å¹¶å‘å‘èµ·è·¨é“¾è½¬è´¦
    const transfers = users.map((user, i) => 
      tokenBridge.methods
        .transferTokens(
          new BN(1000_000_000),
          ETH_CHAIN_ID,
          ethUsdcAddress,
          ethRecipient
        )
        .accounts({
          tokenAccount: user.account,
          tokenAuthority: user.keypair.publicKey,
          // ...
        })
        .signers([user.keypair])
        .rpc()
    );
    
    await Promise.all(transfers);
    
    // 3. éªŒè¯æ‰€æœ‰è½¬è´¦æˆåŠŸ
    const custodyBalance = await getTokenBalance(connection, custodyAccount);
    expect(custodyBalance).to.equal(3000_000_000n);
  });
});
```

**æµ‹è¯•ç¤ºä¾‹ E2E-SOL-008**:
```typescript
describe("å¤§é¢è½¬è´¦å‹åŠ›æµ‹è¯•", () => {
  it("should handle large amount transfer", async () => {
    // 1. åˆ›å»ºå·¨é²¸è´¦æˆ·ï¼ŒæŒæœ‰1,000,000 USDC
    const whaleAccount = await createAndMintTestToken(
      connection, payer, solUsdcMint, alice.publicKey,
      BigInt(1_000_000_000_000)
    );
    
    // 2. è½¬è´¦100,000 USDC
    const largeAmount = new BN(100_000_000_000);
    
    await tokenBridge.methods
      .transferTokens(
        largeAmount,
        ETH_CHAIN_ID,
        ethUsdcAddress,
        ethRecipient
      )
      .rpc();
    
    // 3. éªŒè¯è½¬è´¦æˆåŠŸ
    const custodyBalance = await getTokenBalance(connection, custodyAccount);
    expect(custodyBalance).to.equal(100_000_000_000n);
    
    // 4. éªŒè¯ä½™é¢è®¡ç®—æ­£ç¡®ï¼ˆæ— æº¢å‡ºï¼‰
    const whaleBalance = await getTokenBalance(connection, whaleAccount);
    expect(whaleBalance).to.equal(900_000_000_000n);
  });
});
```

---

## 5. æµ‹è¯•ç¯å¢ƒé…ç½®

### 5.1 æœ¬åœ°æµ‹è¯•ç¯å¢ƒ

#### Anchor.tomlé…ç½®
```toml
[features]
seeds = false
skip-lint = false

[programs.localnet]
solana_core = "worm2ZoG2kUd4vFXhvjh93UUH596ayRfgQ2MgjNMTth"
token_bridge = "wormDTUJ6AWPNvk59vGQbDvGJmqbDTdgWgAqcLBCgUb"

[scripts]
test = "yarn run ts-mocha -p ./tsconfig.json -t 1000000 tests/**/*.ts"

[test]
startup_wait = 5000

[[test.validator.clone]]
address = "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA"

[[test.validator.clone]]
address = "ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL"
```

---

### 5.2 æµ‹è¯•å·¥å…·å‡½æ•°

```typescript
// tests/utils/helpers.ts

/**
 * åˆ›å»ºæµ‹è¯•VAA
 */
export function createTestVAA(params: {
  guardianSetIndex: number;
  emitterChain: number;
  emitterAddress: string;
  sequence: number;
  payload: Buffer;
  guardians: Keypair[];
}): Buffer {
  // VAAæ„é€ é€»è¾‘
  const header = Buffer.alloc(6);
  header.writeUInt8(1, 0);  // version
  header.writeUInt32BE(params.guardianSetIndex, 1);
  header.writeUInt8(params.guardians.length, 5);
  
  // ç­¾åéƒ¨åˆ†
  const bodyHash = keccak256(encodeBody(params));
  const signatures = params.guardians.map((guardian, index) => {
    const sig = guardian.sign(bodyHash);
    return Buffer.concat([
      Buffer.from([index]),
      sig
    ]);
  });
  
  return Buffer.concat([header, ...signatures, encodeBody(params)]);
}

/**
 * ä»Guardian APIè½®è¯¢VAA
 */
export async function pollGuardianForVAA(
  messageId: {
    emitterChain: number;
    emitterAddress: string;
    sequence: number;
  },
  timeout: number = 60000
): Promise<Buffer> {
  const startTime = Date.now();
  
  while (Date.now() - startTime < timeout) {
    try {
      const response = await fetch(
        `http://localhost:7071/v1/signed_vaa/${messageId.emitterChain}/${messageId.emitterAddress}/${messageId.sequence}`
      );
      
      if (response.status === 200) {
        const data = await response.json();
        return Buffer.from(data.vaaBytes.slice(2), 'hex');
      }
      
      if (response.status === 404) {
        throw new Error("VAA not found");
      }
      
      // 202: èšåˆä¸­ï¼Œç»§ç»­ç­‰å¾…
      await new Promise(resolve => setTimeout(resolve, 1000));
    } catch (err) {
      console.log("Polling VAA...", err.message);
      await new Promise(resolve => setTimeout(resolve, 1000));
    }
  }
  
  throw new Error("VAA timeout");
}
```

---

### 5.3 CI/CDé…ç½®

```yaml
# .github/workflows/solana-test.yml
name: Solana Contract Tests

on: [push, pull_request]

jobs:
  test:
    runs-on: ubuntu-latest
    
    steps:
      - uses: actions/checkout@v3
      
      - name: Install Solana
        run: |
          sh -c "$(curl -sSfL https://release.solana.com/stable/install)"
          echo "$HOME/.local/share/solana/install/active_release/bin" >> $GITHUB_PATH
      
      - name: Install Anchor
        run: |
          cargo install --git https://github.com/coral-xyz/anchor anchor-cli --locked
      
      - name: Run Anchor tests
        working-directory: contracts/svm
        run: |
          anchor test
      
      - name: Upload test results
        if: always()
        uses: actions/upload-artifact@v3
        with:
          name: test-results
          path: contracts/svm/test-results/
```

---

## é™„å½•

### A. æµ‹è¯•å®ç°è¯´æ˜

#### A.1 çœŸå®å¯†ç å­¦å®ç°

æµ‹è¯•å¥—ä»¶ä½¿ç”¨**çœŸå®çš„å¯†ç å­¦ç®—æ³•**ï¼Œè€Œä¸æ˜¯æ¨¡æ‹Ÿæ•°æ®ï¼š

**Guardianå¯†é’¥ç”Ÿæˆï¼ˆsecp256k1ï¼‰**:
```typescript
// ä½¿ç”¨ellipticåº“ç”ŸæˆçœŸå®çš„secp256k1å¯†é’¥å¯¹
import { ec as EC } from "elliptic";
const ec = new EC("secp256k1");

export function generateGuardianKey(seed?: Buffer): GuardianKeyPair {
  const privateKey = seed || crypto.randomBytes(32);
  const key = ec.keyFromPrivate(privateKey);
  
  // è®¡ç®—Ethereumå…¼å®¹çš„20å­—èŠ‚åœ°å€
  const publicKey = Buffer.concat([
    Buffer.from(key.getX().toArray('be', 32)),
    Buffer.from(key.getY().toArray('be', 32))
  ]);
  const publicKeyHash = Buffer.from(keccak256(publicKey), 'hex');
  const address = publicKeyHash.slice(-20);
  
  return { privateKey, publicKey, address };
}

// ç”Ÿæˆ19ä¸ªGuardianå¯†é’¥
export const TEST_GUARDIAN_KEYS = generateGuardianKeys(19);
```

**ECDSAç­¾å**:
```typescript
export function signVAA(bodyHash: Buffer, guardianKey: GuardianKeyPair, guardianIndex: number) {
  const key = ec.keyFromPrivate(guardianKey.privateKey);
  const signature = key.sign(bodyHash, { canonical: true });
  
  return {
    guardianIndex,
    r: Buffer.from(signature.r.toArray('be', 32)),
    s: Buffer.from(signature.s.toArray('be', 32)),
    v: signature.recoveryParam!,
  };
}
```

**ç­¾åéªŒè¯**:
```typescript
export function verifyVAASignature(bodyHash: Buffer, signature: Signature, guardianAddress: Buffer) {
  const key = ec.recoverPubKey(bodyHash, { r: signature.r, s: signature.s }, signature.v);
  const publicKey = Buffer.concat([...]);
  const recoveredAddress = Buffer.from(keccak256(publicKey), 'hex').slice(-20);
  return recoveredAddress.equals(guardianAddress);
}
```

#### A.2 VAAæ„é€ 

**å®Œæ•´VAAæ„é€ æµç¨‹**:
```typescript
export function createTokenTransferVAA(params: {
  guardianSetIndex: number;
  emitterChain: number;
  emitterAddress: Buffer;
  sequence: bigint;
  guardianKeys: GuardianKeyPair[];  // çœŸå®çš„secp256k1å¯†é’¥
  transferPayload: TokenTransferPayload;
  signerCount?: number;  // é»˜è®¤13
}): Buffer {
  // 1. åºåˆ—åŒ–Payload
  const payload = serializeTokenTransferPayload(params.transferPayload);
  
  // 2. åºåˆ—åŒ–Body
  const bodyBuffer = serializeVAABody({ timestamp, nonce, emitterChain, ... });
  
  // 3. è®¡ç®—åŒé‡å“ˆå¸Œ
  const bodyHash = keccak256(bodyBuffer);
  const doubleHash = keccak256(bodyHash);
  
  // 4. ç”ŸæˆçœŸå®ç­¾åï¼ˆ13ä¸ªGuardianï¼‰
  const signatures = [];
  for (let i = 0; i < 13; i++) {
    signatures.push(signVAA(doubleHash, guardianKeys[i], i));
  }
  
  // 5. åºåˆ—åŒ–å®Œæ•´VAA
  return serializeVAA({ version: 1, guardianSetIndex, signatures, ... });
}
```

#### A.3 æµ‹è¯•è¿è¡Œ

```bash
# è¿è¡Œå¯†ç å­¦æ¼”ç¤ºæµ‹è¯•
cd contracts/svm/bridge-programs
ts-mocha -p ./tsconfig.json tests/demo-crypto.test.ts

# è¾“å‡ºç¤ºä¾‹ï¼š
# âœ“ ç”Ÿæˆ19ä¸ªGuardianå¯†é’¥
#   Guardian 0: 0x8c8c3c3d9e8e8e8e8e8e8e8e8e8e8e8e8e8e8e8e
# âœ“ ECDSAç­¾åå’ŒéªŒè¯: âœ“ é€šè¿‡
# âœ“ VAAæ„é€ å®Œæˆ: 1122 bytes, 13/13ç­¾åéªŒè¯é€šè¿‡
```

#### A.4 æµ‹è¯•è¦†ç›–

| åŠŸèƒ½ | å®ç°æ–¹å¼ | çŠ¶æ€ |
|------|---------|------|
| secp256k1å¯†é’¥ç”Ÿæˆ | `elliptic`åº“ | âœ… çœŸå®å®ç° |
| ECDSAç­¾å | `elliptic.sign()` | âœ… çœŸå®å®ç° |
| ç­¾åéªŒè¯ | `elliptic.recoverPubKey()` | âœ… çœŸå®å®ç° |
| Keccak256å“ˆå¸Œ | `js-sha3` | âœ… çœŸå®å®ç° |
| VAAåºåˆ—åŒ– | ç¬¦åˆWormholeåè®® | âœ… å®Œæ•´å®ç° |
| TokenTransfer Payload | 133å­—èŠ‚æ ¼å¼ | âœ… å®Œæ•´å®ç° |
| GuardianSetUpgrade Payload | å¯å˜é•¿åº¦æ ¼å¼ | âœ… å®Œæ•´å®ç° |

---

### B. è¦†ç›–ç‡æŠ¥å‘Š

ä½¿ç”¨ `anchor-coverage` å·¥å…·ç”Ÿæˆè¦†ç›–ç‡æŠ¥å‘Šï¼š

```bash
cd contracts/svm
anchor test --skip-deploy
anchor coverage
```

**ç›®æ ‡è¦†ç›–ç‡**:
- æŒ‡ä»¤è¦†ç›–ç‡: 100%
- åˆ†æ”¯è¦†ç›–ç‡: 90%
- è¡Œè¦†ç›–ç‡: 90%

---

**æ–‡æ¡£çŠ¶æ€**: âœ… v1.0 åˆç‰ˆå®Œæˆ  
**ç»´æŠ¤è€…**: Solanaåˆçº¦æµ‹è¯•å›¢é˜Ÿ

