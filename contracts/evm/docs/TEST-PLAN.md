# EVMåˆçº¦å­æ¨¡å— - æµ‹è¯•å¥—ä»¶è§„åˆ’

> **æ–‡æ¡£ç‰ˆæœ¬**: v1.0  
> **åˆ›å»ºæ—¥æœŸ**: 2025-11-09  
> **å­æ¨¡å—**: EVMæ™ºèƒ½åˆçº¦  
> **çˆ¶é¡¹ç›®**: è·¨é“¾æ¡¥é¡¹ç›®

---

## ğŸ“‹ ç›®å½•

1. [æµ‹è¯•ç­–ç•¥](#1-æµ‹è¯•ç­–ç•¥)
2. [å•å…ƒæµ‹è¯•è§„åˆ’](#2-å•å…ƒæµ‹è¯•è§„åˆ’)
3. [é›†æˆæµ‹è¯•è§„åˆ’](#3-é›†æˆæµ‹è¯•è§„åˆ’)
4. [æµ‹è¯•ç¯å¢ƒé…ç½®](#4-æµ‹è¯•ç¯å¢ƒé…ç½®)
5. [æµ‹è¯•æ•°æ®å‡†å¤‡](#5-æµ‹è¯•æ•°æ®å‡†å¤‡)

---

## 1. æµ‹è¯•ç­–ç•¥

### 1.1 æµ‹è¯•åˆ†å±‚

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  é›†æˆæµ‹è¯•                                 â”‚  30%
â”‚  - åˆçº¦é—´äº¤äº’                             â”‚
â”‚  - è·¨é“¾æµç¨‹æ¨¡æ‹Ÿ                           â”‚
â”‚  - Guardianç­¾åé›†æˆ                       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                 â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  å•å…ƒæµ‹è¯•                                 â”‚  70%
â”‚  - BridgeCoreå‡½æ•°                        â”‚
â”‚  - TokenVaultå‡½æ•°ï¼ˆå«TokenBindingï¼‰      â”‚
â”‚  - ç®¡ç†åŠŸèƒ½                              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

### 1.2 æµ‹è¯•è¦†ç›–ç›®æ ‡

| æµ‹è¯•ç±»å‹ | è¦†ç›–ç‡ç›®æ ‡ | ç”¨ä¾‹æ•° | é¢„è®¡æ—¶é—´ |
|---------|-----------|--------|---------|
| **å•å…ƒæµ‹è¯•** | 95%ä»£ç  | 53ä¸ª | 15åˆ†é’Ÿ |
| **é›†æˆæµ‹è¯•** | 80%åœºæ™¯ | 13ä¸ª | 10åˆ†é’Ÿ |
| **æ€»è®¡** | - | **66ä¸ª** | **25åˆ†é’Ÿ** |

---

### 1.3 æµ‹è¯•ä¼˜å…ˆçº§

| ä¼˜å…ˆçº§ | æµ‹è¯•å†…å®¹ | è¯´æ˜ |
|-------|---------|------|
| **P0** | VAAéªŒè¯ã€ä»£å¸é”å®š/è§£é”ã€é˜²é‡æ”¾ | æ ¸å¿ƒåŠŸèƒ½ï¼Œå¿…é¡»é€šè¿‡ |
| **P1** | é€Ÿç‡é™åˆ¶ã€æƒé™æ§åˆ¶ã€é”™è¯¯å¤„ç† | é‡è¦åŠŸèƒ½ |
| **P2** | Gasä¼˜åŒ–ã€è¾¹ç•Œæ¡ä»¶ | è¾…åŠ©åŠŸèƒ½ |

---

## 2. å•å…ƒæµ‹è¯•è§„åˆ’

### 2.1 BridgeCore.solæµ‹è¯•

#### 2.1.1 publishMessageå‡½æ•°æµ‹è¯•

| æµ‹è¯•ID | æµ‹è¯•åœºæ™¯ | é¢„æœŸç»“æœ | ä¼˜å…ˆçº§ |
|-------|---------|---------|--------|
| CORE-001 | æ­£å¸¸å‘å¸ƒæ¶ˆæ¯ | è¿”å›åºåˆ—å·ï¼Œå‘å‡ºäº‹ä»¶ | P0 |
| CORE-002 | æ‰‹ç»­è´¹ä¸è¶³ | revert InsufficientFee | P0 |
| CORE-003 | åºåˆ—å·é€’å¢ | æ¯æ¬¡è°ƒç”¨é€’å¢1 | P0 |
| CORE-004 | åˆçº¦æš‚åœæ—¶å‘å¸ƒ | revert BridgePaused | P0 |
| CORE-005 | ç©ºpayload | æ­£å¸¸æ‰§è¡Œ | P1 |
| CORE-006 | å¤§payloadï¼ˆ32KBï¼‰ | æ­£å¸¸æ‰§è¡Œ | P1 |
| CORE-007 | ä¸åŒconsistencyLevel | æ­£ç¡®å­˜å‚¨ | P1 |

**æµ‹è¯•ä»£ç ç¤ºä¾‹**:
```solidity
function testPublishMessage() public {
    bytes memory payload = hex"010203";
    uint256 fee = bridgeCore.messageFee();
    
    vm.expectEmit(true, true, true, true);
    emit LogMessagePublished(
        address(this),
        0,  // sequence
        123,  // nonce
        payload,
        200  // consistencyLevel
    );
    
    uint64 seq = bridgeCore.publishMessage{value: fee}(
        123,
        payload,
        200
    );
    
    assertEq(seq, 0);
}

function testPublishMessage_InsufficientFee() public {
    bytes memory payload = hex"010203";
    
    vm.expectRevert(InsufficientFee.selector);
    bridgeCore.publishMessage{value: 0}(123, payload, 200);
}
```

---

#### 2.1.2 VAAè§£æä¸éªŒè¯æµ‹è¯•

| æµ‹è¯•ID | æµ‹è¯•åœºæ™¯ | é¢„æœŸç»“æœ | ä¼˜å…ˆçº§ |
|-------|---------|---------|--------|
| CORE-008 | æœ‰æ•ˆVAAè§£æ | æ­£ç¡®è§£ææ‰€æœ‰å­—æ®µ | P0 |
| CORE-009 | æ— æ•ˆVAAæ ¼å¼ | revert InvalidVAA | P0 |
| CORE-010 | ç­¾åæ•°é‡ä¸è¶³ï¼ˆ12ä¸ªï¼‰ | revert InsufficientSignatures | P0 |
| CORE-011 | ç­¾åæ•°é‡è¾¾åˆ°é—¨é™ï¼ˆ13ä¸ªï¼‰ | éªŒè¯é€šè¿‡ | P0 |
| CORE-012 | ç­¾åæ•°é‡è¶…è¿‡é—¨é™ï¼ˆ15ä¸ªï¼‰ | éªŒè¯é€šè¿‡ | P0 |
| CORE-013 | æ— æ•ˆç­¾å | revert InvalidSignature | P0 |
| CORE-014 | Guardian Setä¸åŒ¹é… | revert InvalidGuardianSet | P0 |
| CORE-015 | è¿‡æœŸçš„Guardian Set | revert InvalidGuardianSet | P0 |

**æµ‹è¯•ä»£ç ç¤ºä¾‹**:
```solidity
function testReceiveMessage_ValidVAA() public {
    // æ„é€ æœ‰æ•ˆVAAï¼ˆ13ä¸ªç­¾åï¼‰
    bytes memory vaa = buildValidVAA(
        guardianSet0,
        13,  // 13ä¸ªç­¾å
        payload
    );
    
    bool success = bridgeCore.receiveMessage(vaa);
    
    assertTrue(success);
    bytes32 vaaHash = keccak256(vaa);
    assertTrue(bridgeCore.isVAAConsumed(vaaHash));
}

function testReceiveMessage_InsufficientSignatures() public {
    // æ„é€ VAAï¼ˆåªæœ‰12ä¸ªç­¾åï¼‰
    bytes memory vaa = buildValidVAA(
        guardianSet0,
        12,  // ä¸è¶³é—¨é™
        payload
    );
    
    vm.expectRevert(InsufficientSignatures.selector);
    bridgeCore.receiveMessage(vaa);
}
```

---

#### 2.1.3 é˜²é‡æ”¾æµ‹è¯•

| æµ‹è¯•ID | æµ‹è¯•åœºæ™¯ | é¢„æœŸç»“æœ | ä¼˜å…ˆçº§ |
|-------|---------|---------|--------|
| CORE-016 | é¦–æ¬¡æäº¤VAA | æˆåŠŸ | P0 |
| CORE-017 | é‡å¤æäº¤ç›¸åŒVAA | revert VAAAlreadyConsumed | P0 |
| CORE-018 | æŸ¥è¯¢æœªæ¶ˆè´¹VAA | è¿”å›false | P0 |
| CORE-019 | æŸ¥è¯¢å·²æ¶ˆè´¹VAA | è¿”å›true | P0 |

---

#### 2.1.4 Guardian Setç®¡ç†æµ‹è¯•

| æµ‹è¯•ID | æµ‹è¯•åœºæ™¯ | é¢„æœŸç»“æœ | ä¼˜å…ˆçº§ |
|-------|---------|---------|--------|
| CORE-020 | å‡çº§Guardian Set | æ–°Setæ¿€æ´»ï¼Œæ—§Setè®¾ç½®è¿‡æœŸæ—¶é—´ | P0 |
| CORE-021 | æŸ¥è¯¢å½“å‰Guardian Set | è¿”å›æ­£ç¡®ç´¢å¼• | P0 |
| CORE-022 | è¿‡æ¸¡æœŸä½¿ç”¨æ—§Setç­¾å | éªŒè¯é€šè¿‡ | P0 |
| CORE-023 | è¿‡æ¸¡æœŸä½¿ç”¨æ–°Setç­¾å | éªŒè¯é€šè¿‡ | P0 |
| CORE-024 | è¿‡æœŸåä½¿ç”¨æ—§Set | revert InvalidGuardianSet | P0 |
| CORE-025 | æœªæˆæƒå‡çº§ | revertï¼ˆé€šè¿‡VAAéªŒè¯ï¼‰ | P0 |

---

### 2.2 TokenVault.solæµ‹è¯•

#### 2.2.1 lockTokenså‡½æ•°æµ‹è¯•

| æµ‹è¯•ID | æµ‹è¯•åœºæ™¯ | é¢„æœŸç»“æœ | ä¼˜å…ˆçº§ |
|-------|---------|---------|--------|
| VAULT-001 | æ­£å¸¸é”å®šERC20 | ä»£å¸è½¬å…¥Vaultï¼Œå‘å‡ºäº‹ä»¶ | P0 |
| VAULT-002 | æˆæƒä¸è¶³ | revert (ERC20: insufficient allowance) | P0 |
| VAULT-003 | ä½™é¢ä¸è¶³ | revert (ERC20: transfer amount exceeds balance) | P0 |
| VAULT-004 | è¶…å‡ºå•ç¬”é™é¢ | revert ExceedsRateLimit | P0 |
| VAULT-005 | è¶…å‡ºæ¯æ—¥é™é¢ | revert ExceedsRateLimit | P0 |
| VAULT-006 | æ‰‹ç»­è´¹ä¸è¶³ | revert InsufficientFee | P0 |
| VAULT-007 | æ— æ•ˆç›®æ ‡é“¾ID | revert InvalidChainId | P0 |
| VAULT-008 | åˆçº¦æš‚åœæ—¶é”å®š | revert BridgePaused | P0 |
| VAULT-009 | é›¶é‡‘é¢è½¬è´¦ | revertæˆ–æ­£å¸¸ï¼ˆæ ¹æ®è®¾è®¡ï¼‰ | P1 |
| VAULT-010 | éå¸¸å¤§é‡‘é¢ï¼ˆuint256.maxï¼‰ | æŒ‰é™é¢æ£€æŸ¥ | P1 |

**æµ‹è¯•ä»£ç ç¤ºä¾‹**:
```solidity
function testLockTokens_Success() public {
    uint256 amount = 1000e6;  // 1000 USDC
    
    // æˆæƒ
    usdc.approve(address(vault), amount);
    
    // è®°å½•åˆå§‹ä½™é¢
    uint256 userBalanceBefore = usdc.balanceOf(user);
    uint256 vaultBalanceBefore = usdc.balanceOf(address(vault));
    
    // é”å®šä»£å¸
    vm.expectEmit(true, true, true, true);
    emit TokensLocked(
        transferId,
        address(usdc),
        user,
        amount,
        2,  // Solana
        recipientBytes32
    );
    
    bytes32 transferId = vault.lockTokens{value: 0.001 ether}(
        address(usdc),
        amount,
        2,  // target chain: Solana
        recipientBytes32
    );
    
    // éªŒè¯ä½™é¢å˜åŒ–
    assertEq(usdc.balanceOf(user), userBalanceBefore - amount);
    assertEq(usdc.balanceOf(address(vault)), vaultBalanceBefore + amount);
}

function testLockTokens_ExceedsRateLimit() public {
    uint256 amount = 2_000_000e6;  // 2M USDCï¼Œè¶…è¿‡å•ç¬”é™é¢
    
    usdc.approve(address(vault), amount);
    
    vm.expectRevert(ExceedsRateLimit.selector);
    vault.lockTokens{value: 0.001 ether}(
        address(usdc),
        amount,
        2,
        recipientBytes32
    );
}
```

---

#### 2.2.2 unlockTokenså‡½æ•°æµ‹è¯•

| æµ‹è¯•ID | æµ‹è¯•åœºæ™¯ | é¢„æœŸç»“æœ | ä¼˜å…ˆçº§ |
|-------|---------|---------|--------|
| VAULT-011 | æ­£å¸¸è§£é”ä»£å¸ | ä»£å¸è½¬ç»™æ¥æ”¶è€… | P0 |
| VAULT-012 | VAAæ— æ•ˆ | revert InvalidVAA | P0 |
| VAULT-013 | VAAå·²æ¶ˆè´¹ | revert VAAAlreadyConsumed | P0 |
| VAULT-014 | Vaultä½™é¢ä¸è¶³ | revert InsufficientBalance | P0 |
| VAULT-015 | é”™è¯¯çš„ä»£å¸åœ°å€ | revert InvalidToken | P0 |
| VAULT-016 | åˆçº¦æš‚åœæ—¶è§£é” | revert BridgePaused | P0 |

---

#### 2.2.3 é€Ÿç‡é™åˆ¶æµ‹è¯•

| æµ‹è¯•ID | æµ‹è¯•åœºæ™¯ | é¢„æœŸç»“æœ | ä¼˜å…ˆçº§ |
|-------|---------|---------|--------|
| VAULT-022 | å•ç¬”é™é¢è¾¹ç•Œå€¼ | æ­£å¥½ç­‰äºé™é¢æ—¶æˆåŠŸ | P0 |
| VAULT-023 | å•ç¬”é™é¢+1 | revert ExceedsRateLimit | P0 |
| VAULT-024 | ç´¯è®¡åˆ°æ¯æ—¥é™é¢ | æœ€åä¸€ç¬”æˆåŠŸ | P0 |
| VAULT-025 | è¶…è¿‡æ¯æ—¥é™é¢ | revert ExceedsRateLimit | P0 |
| VAULT-026 | 24å°æ—¶åé‡ç½® | é™é¢é‡ç½®ï¼Œå¯å†æ¬¡è½¬è´¦ | P0 |
| VAULT-027 | æ›´æ–°é€Ÿç‡é™åˆ¶ | æ–°é™é¢ç”Ÿæ•ˆ | P1 |

---

### 2.3 ç®¡ç†åŠŸèƒ½æµ‹è¯•

| æµ‹è¯•ID | æµ‹è¯•åœºæ™¯ | é¢„æœŸç»“æœ | ä¼˜å…ˆçº§ |
|-------|---------|---------|--------|
| ADMIN-001 | Governanceæš‚åœåˆçº¦ | åˆçº¦æš‚åœ | P0 |
| ADMIN-002 | éGovernanceæš‚åœ | revert Unauthorized | P0 |
| ADMIN-003 | Governanceæ¢å¤åˆçº¦ | åˆçº¦æ¢å¤ | P0 |
| ADMIN-004 | è®¾ç½®é€Ÿç‡é™åˆ¶ | æ–°é™é¢ç”Ÿæ•ˆ | P0 |
| ADMIN-005 | éGovernanceè®¾ç½®é™é¢ | revert Unauthorized | P0 |
| ADMIN-006 | æå–æ‰‹ç»­è´¹ | æˆåŠŸæå– | P0 |
| ADMIN-007 | éGovernanceæå– | revert Unauthorized | P0 |
| ADMIN-008 | æå–è¶…è¿‡ä½™é¢ | revert InsufficientBalance | P0 |

---

## 3. é›†æˆæµ‹è¯•è§„åˆ’

### 3.1 å®Œæ•´è·¨é“¾æµç¨‹æµ‹è¯•

| æµ‹è¯•ID | æµ‹è¯•åœºæ™¯ | æ­¥éª¤ | ä¼˜å…ˆçº§ |
|-------|---------|------|--------|
| INT-001 | Ethereum â†’ Solanaå®Œæ•´æµç¨‹ | é”å®šâ†’VAAâ†’éªŒè¯â†’é“¸é€  | P0 |
| INT-002 | åŒ…è£…ä»£å¸èµå›æµç¨‹ | é”€æ¯â†’VAAâ†’éªŒè¯â†’è§£é” | P0 |
| INT-003 | å¤šæ¬¡è·¨é“¾å¾€è¿” | å¤šæ¬¡Lock/Unlockå¾ªç¯ | P1 |

**æµ‹è¯•ä»£ç ç¤ºä¾‹**:
```solidity
function testIntegration_FullCrossChainFlow() public {
    // æ­¥éª¤1: åœ¨æºé“¾é”å®šä»£å¸
    uint256 amount = 1000e6;
    usdc.approve(address(vault), amount);
    
    bytes32 transferId = vault.lockTokens{value: 0.001 ether}(
        address(usdc),
        amount,
        2,  // Solana
        recipientBytes32
    );
    
    // éªŒè¯ï¼šä»£å¸å·²é”å®š
    assertEq(usdc.balanceOf(address(vault)), amount);
    
    // æ­¥éª¤2: æ¨¡æ‹ŸGuardianç­¾å
    bytes memory vaa = buildVAAFromTransfer(
        transferId,
        guardianSet,
        13  // 13ä¸ªç­¾å
    );
    
    // æ­¥éª¤3: åœ¨ç›®æ ‡é“¾éªŒè¯VAA
    bool success = bridgeCore.receiveMessage(vaa);
    assertTrue(success);
    
    // æ­¥éª¤4: é€šè¿‡TokenBindingè§£é”å¯¹åº”ä»£å¸ï¼ˆæ¨¡æ‹Ÿï¼‰
    // æ³¨ï¼šå®é™…åœ¨Solanaé“¾ä¸Šé€šè¿‡TokenBindingæœºåˆ¶è§£é”
    bytes32 vaaHash = keccak256(vaa);
    assertTrue(bridgeCore.isVAAConsumed(vaaHash));
}
```

---

### 3.2 Guardian Setå‡çº§æµ‹è¯•

| æµ‹è¯•ID | æµ‹è¯•åœºæ™¯ | é¢„æœŸç»“æœ | ä¼˜å…ˆçº§ |
|-------|---------|---------|--------|
| INT-004 | Guardian Setå‡çº§ | æ–°æ—§Setå…±å­˜7å¤© | P0 |
| INT-005 | å‡çº§æœŸé—´è·¨é“¾ | æ—§Setç­¾åä»æœ‰æ•ˆ | P0 |
| INT-006 | å‡çº§åç«‹å³è·¨é“¾ | æ–°Setç­¾åæœ‰æ•ˆ | P0 |
| INT-007 | è¿‡æœŸåä½¿ç”¨æ—§Set | æ‹’ç» | P0 |

---

### 3.3 å¼‚å¸¸åœºæ™¯æµ‹è¯•

| æµ‹è¯•ID | æµ‹è¯•åœºæ™¯ | é¢„æœŸç»“æœ | ä¼˜å…ˆçº§ |
|-------|---------|---------|--------|
| INT-008 | é‡å¤æäº¤VAA | ç¬¬äºŒæ¬¡å¤±è´¥ | P0 |
| INT-009 | Gasä¸è¶³å¯¼è‡´å¤±è´¥ | å¯é‡è¯• | P0 |
| INT-010 | åˆçº¦æš‚åœæœŸé—´æ“ä½œ | å…¨éƒ¨æ‹’ç» | P0 |
| INT-011 | å¤šåˆçº¦å¹¶å‘æ“ä½œ | æ— ç«æ€æ¡ä»¶ | P1 |

---

## 4. æµ‹è¯•ç¯å¢ƒé…ç½®

### 4.1 Foundryé…ç½®

```toml
# foundry.toml
[profile.default]
src = "src"
out = "out"
libs = ["lib"]
solc_version = "0.8.20"
optimizer = true
optimizer_runs = 200
via_ir = false

[profile.default.fuzz]
runs = 256
max_test_rejects = 65536

[profile.ci]
fuzz = { runs = 5000 }
invariant = { runs = 1000 }
```

---

### 4.2 æµ‹è¯•ç¯å¢ƒéƒ¨ç½²

```solidity
// test/Setup.sol
contract TestSetup is Test {
    BridgeCore public bridgeCore;
    TokenVault public vault;
    MockERC20 public usdc;
    
    address public governance = address(0x1);
    address public user = address(0x2);
    
    // Guardianå¯†é’¥ï¼ˆæµ‹è¯•ç”¨ï¼‰
    address[] public guardians;
    
    function setUp() public {
        // éƒ¨ç½²åˆçº¦
        bridgeCore = new BridgeCore();
        vault = new TokenVault(address(bridgeCore));
        usdc = new MockERC20("USD Coin", "USDC", 6);
        
        // åˆå§‹åŒ–Guardian Set
        guardians = new address[](19);
        for (uint i = 0; i < 19; i++) {
            guardians[i] = vm.addr(i + 1);
        }
        bridgeCore.initialize(guardians, governance);
        
        // è®¾ç½®æµ‹è¯•è´¦æˆ·
        vm.deal(user, 100 ether);
        usdc.mint(user, 10_000_000e6);  // 10M USDC
    }
}
```

---

### 4.3 Mockåˆçº¦

```solidity
// test/mocks/MockERC20.sol
contract MockERC20 is ERC20 {
    uint8 private _decimals;
    
    constructor(
        string memory name,
        string memory symbol,
        uint8 decimals_
    ) ERC20(name, symbol) {
        _decimals = decimals_;
    }
    
    function mint(address to, uint256 amount) external {
        _mint(to, amount);
    }
    
    function decimals() public view override returns (uint8) {
        return _decimals;
    }
}
```

---

## 5. æµ‹è¯•æ•°æ®å‡†å¤‡

### 5.1 æµ‹è¯•è´¦æˆ·

```solidity
// æµ‹è¯•ç§é’¥ï¼ˆä»…æµ‹è¯•ç”¨ï¼‰
uint256 constant USER_KEY = 0x1234...;
uint256 constant GUARDIAN_0_KEY = 0x5678...;
// ... 19ä¸ªGuardianç§é’¥

// æ´¾ç”Ÿåœ°å€
address user = vm.addr(USER_KEY);
address guardian0 = vm.addr(GUARDIAN_0_KEY);
```

---

### 5.2 æµ‹è¯•VAAæ„é€ 

```solidity
function buildValidVAA(
    address[] memory guardianSet,
    uint8 numSignatures,
    bytes memory payload
) internal returns (bytes memory) {
    // 1. æ„é€ VAA Body
    bytes memory body = abi.encodePacked(
        uint32(block.timestamp),  // timestamp
        uint32(12345),            // nonce
        uint16(1),                // emitterChain
        bytes32(uint256(uint160(address(this)))),  // emitter
        uint64(0),                // sequence
        uint8(200),               // consistencyLevel
        payload
    );
    
    bytes32 bodyHash = keccak256(body);
    
    // 2. Guardianç­¾å
    bytes memory signatures = "";
    for (uint8 i = 0; i < numSignatures; i++) {
        uint256 guardianKey = i + 1;
        (uint8 v, bytes32 r, bytes32 s) = vm.sign(guardianKey, bodyHash);
        
        signatures = abi.encodePacked(
            signatures,
            uint8(i),  // guardianIndex
            r,
            s,
            v
        );
    }
    
    // 3. æ„é€ å®Œæ•´VAA
    return abi.encodePacked(
        uint8(1),             // version
        uint32(0),            // guardianSetIndex
        uint8(numSignatures), // signaturesLength
        signatures,
        body
    );
}
```

---

### 5.3 æµ‹è¯•ä»£å¸

```solidity
// éƒ¨ç½²æµ‹è¯•ä»£å¸
MockERC20 usdc = new MockERC20("USD Coin", "USDC", 6);
MockERC20 usdt = new MockERC20("Tether USD", "USDT", 6);
MockERC20 weth = new MockERC20("Wrapped Ether", "WETH", 18);

// é“¸é€ æµ‹è¯•ä»£å¸
usdc.mint(user1, 10_000_000e6);  // 10M USDC
usdt.mint(user2, 5_000_000e6);   // 5M USDT
weth.mint(user3, 1000e18);       // 1000 WETH
```

---

## 6. æµ‹è¯•æ‰§è¡Œ

### 6.1 è¿è¡Œæµ‹è¯•

```bash
# è¿è¡Œæ‰€æœ‰æµ‹è¯•
forge test

# è¿è¡Œç‰¹å®šåˆçº¦æµ‹è¯•
forge test --match-contract BridgeCoreTest

# è¿è¡Œç‰¹å®šå‡½æ•°æµ‹è¯•
forge test --match-test testPublishMessage

# æ˜¾ç¤ºè¯¦ç»†æ—¥å¿—
forge test -vvv

# æ˜¾ç¤ºGasæŠ¥å‘Š
forge test --gas-report

# æ˜¾ç¤ºè¦†ç›–ç‡
forge coverage
```

---

### 6.2 æµ‹è¯•æŠ¥å‘Š

```bash
# ç”ŸæˆHTMLè¦†ç›–ç‡æŠ¥å‘Š
forge coverage --report lcov
genhtml lcov.info -o coverage/

# æŸ¥çœ‹æŠ¥å‘Š
open coverage/index.html
```

---

## 7. CI/CDé›†æˆ

### 7.1 GitHub Actionsé…ç½®

```yaml
name: EVM Contracts Test

on: [push, pull_request]

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
        with:
          submodules: recursive
      
      - name: Install Foundry
        uses: foundry-rs/foundry-toolchain@v1
      
      - name: Run tests
        run: |
          cd contracts/evm
          forge test -vvv
      
      - name: Check coverage
        run: |
          cd contracts/evm
          forge coverage --report summary
```

---

## 8. æµ‹è¯•æŒ‡æ ‡

### 8.1 è¦†ç›–ç‡ç›®æ ‡

| æŒ‡æ ‡ | ç›®æ ‡å€¼ | å½“å‰å€¼ | çŠ¶æ€ |
|-----|--------|--------|------|
| è¡Œè¦†ç›–ç‡ | â‰¥95% | 0% | ğŸ“… |
| åˆ†æ”¯è¦†ç›–ç‡ | â‰¥90% | 0% | ğŸ“… |
| å‡½æ•°è¦†ç›–ç‡ | â‰¥100% | 0% | ğŸ“… |

---

### 8.2 æµ‹è¯•å®Œæˆåº¦

| åˆçº¦ | æ€»ç”¨ä¾‹ | å·²å®Œæˆ | é€šè¿‡ | å¤±è´¥ |
|-----|--------|--------|------|------|
| BridgeCore.sol | 25 | 0 | 0 | 0 |
| TokenVault.sol | 20 | 0 | 0 | 0 |
| ç®¡ç†åŠŸèƒ½ | 8 | 0 | 0 | 0 |
| é›†æˆæµ‹è¯• | 13 | 0 | 0 | 0 |
| **æ€»è®¡** | **66** | **0** | **0** | **0** |

---

## é™„å½•

### A. æµ‹è¯•æœ€ä½³å®è·µ

1. **å‘½åè§„èŒƒ**: `test<FunctionName>_<Scenario>`
2. **æ–­è¨€**: ä½¿ç”¨æ˜ç¡®çš„é”™è¯¯æ¶ˆæ¯
3. **éš”ç¦»æ€§**: æ¯ä¸ªæµ‹è¯•ç‹¬ç«‹ï¼Œä¸ä¾èµ–å…¶ä»–æµ‹è¯•
4. **å¯è¯»æ€§**: æ¸…æ™°çš„æ³¨é‡Šå’Œæ­¥éª¤è¯´æ˜
5. **è¾¹ç•Œæµ‹è¯•**: æµ‹è¯•è¾¹ç•Œå€¼å’Œæç«¯æƒ…å†µ

### B. å¸¸ç”¨æµ‹è¯•å·¥å…·å‡½æ•°

```solidity
// æ—¶é—´æ“ä½œ
vm.warp(timestamp);  // è®¾ç½®block.timestamp
vm.roll(blockNumber);  // è®¾ç½®block.number

// è´¦æˆ·æ“ä½œ
vm.prank(user);  // ä¸‹ä¸€ä¸ªè°ƒç”¨ä»¥userèº«ä»½
vm.startPrank(user);  // åç»­è°ƒç”¨éƒ½ä»¥userèº«ä»½
vm.stopPrank();

// ä½™é¢æ“ä½œ
vm.deal(user, 100 ether);  // è®¾ç½®ETHä½™é¢

// æœŸæœ›äº‹ä»¶
vm.expectEmit(true, true, true, true);
emit EventName(args...);

// æœŸæœ›å›æ»š
vm.expectRevert(ErrorSelector);
```

### C. ç›¸å…³æ–‡æ¡£

- [çˆ¶é¡¹ç›®æµ‹è¯•è§„åˆ’](../../../docs/TEST-PLAN.md)
- [Foundryæµ‹è¯•æ–‡æ¡£](https://book.getfoundry.sh/forge/tests)
- [OpenZeppelinæµ‹è¯•åŠ©æ‰‹](https://docs.openzeppelin.com/test-helpers/)

---

**æ–‡æ¡£çŠ¶æ€**: âœ… v1.0 å·²å®Œæˆ  
**ç»´æŠ¤**: EVMåˆçº¦æµ‹è¯•å›¢é˜Ÿ  
**æœ€åæ›´æ–°**: 2025-11-09

